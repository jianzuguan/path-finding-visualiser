{"version":3,"sources":["components/index.ts","components/Node.tsx","algorithms/dijkstra.ts","PathFindingVisualiser/index.tsx","utils.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["components","Node","props","nodeObj","row","col","isStart","isEnd","weight","colourStyle","className","id","updateUnvisitedNeighbors","currentNode","grid","unvisitedNeighbors","node","neighbors","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","newDistance","distance","previousNode","dijkstra","stratNode","finishNode","unvisitedNodes","nodes","getAllNodes","visitedNodesInOrder","sort","nodeA","nodeB","closestNode","shift","Infinity","createNode","min","max","Math","ceil","floor","random","PathFindingVisualiser","useState","setGrid","animateShortestPath","nodesInShortestPathOrder","i","setTimeout","domElement","document","getElementById","animateDijkstra","a","useEffect","initialGrid","currentRow","getInitialGrid","onClick","undefined","startNode","endNode","console","log","unshift","getNodesInShortestPathOrder","map","rowIndex","nodeIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.3829608f.chunk.js","sourcesContent":["import Node from \"./Node\";\n\nconst components = {\n  Node,\n};\n\nexport default components;\n","import  \"./Node.css\";\nimport TypeNode from \"../types/Node\";\n\ninterface Props {\n  nodeObj: TypeNode;\n}\n\nconst Node = (props: Props) => {\n  const { row, col, isStart, isEnd, weight } = props.nodeObj;\n\n  const colourStyle = isStart ? 'node-start' : isEnd ? 'node-end' : \"\";\n\n  return <div className={`node ${colourStyle}`} id={`node-${row}-${col}`}>{weight}</div>;\n};\n\nexport default Node;\n","import TypeNode from \"../types/Node\";\n\nconst getAllNodes = (grid: TypeNode[][]) => {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nconst sortNodesByDistance = (unvisitedNoes: TypeNode[]) => {\n  unvisitedNoes.sort(\n    (nodeA: TypeNode, nodeB: TypeNode) => nodeA.distance - nodeB.distance\n  );\n};\n\nconst getUnvisitedNeighbors = (node: TypeNode, grid: TypeNode[][]) => {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};\n\nconst updateUnvisitedNeighbors = (\n  currentNode: TypeNode,\n  grid: TypeNode[][]\n) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const newDistance= currentNode.distance + neighbor.weight;\n    if (newDistance < neighbor.distance) {\n      neighbor.distance = newDistance;\n      neighbor.previousNode = currentNode;\n    }\n  }\n};\n\nconst dijkstra = (\n  grid: TypeNode[][],\n  stratNode: TypeNode,\n  finishNode: TypeNode\n) => {\n  const unvisitedNodes = getAllNodes(grid);\n  stratNode.distance = 0;\n  const visitedNodesInOrder = [];\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (!closestNode) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n\n  return visitedNodesInOrder;\n};\n\nexport const getNodesInShortestPathOrder = (endNode: TypeNode) => {\n  const nodesInShortestPathOrder = [];\n  let currentNode: TypeNode | null = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport default dijkstra;\n","import { useEffect, useState } from \"react\";\nimport TypeNode from \"../types/Node\";\nimport Components from \"../components\";\nimport dijkstra, { getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\nimport \"./index.css\";\nimport { getRandomInt } from \"../utils\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 10;\nconst END_NODE_ROW = 30;\nconst END_NODE_COL = 30;\n\nconst createNode = (col: number, row: number): TypeNode => {\n  return {\n    col,\n    row,\n    isStart: START_NODE_COL === col && START_NODE_ROW === row,\n    isEnd: END_NODE_COL === col && END_NODE_ROW === row,\n    weight: getRandomInt(1, 100),\n    distance: Infinity,\n    isVisited: false,\n    previousNode: null,\n  };\n};\n\nconst getInitialGrid = () => {\n  const grid: TypeNode[][] = [];\n  for (let row = 0; row < 40; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst PathFindingVisualiser = () => {\n  const [grid, setGrid] = useState<TypeNode[][]>();\n\n  const animateShortestPath = (nodesInShortestPathOrder: TypeNode[]) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (\n          node === null ||\n          (START_NODE_ROW === node.row && START_NODE_COL === node.col) ||\n          (END_NODE_ROW === node.row && END_NODE_COL === node.col)\n        ) {\n          return;\n        }\n        const domElement = document.getElementById(\n          `node-${node.row}-${node.col}`\n        );\n        if (domElement === null) {\n          return;\n        }\n        domElement.className = \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const animateDijkstra = async (\n    visitedNodesInOrder: TypeNode[],\n    nodesInShortestPathOrder: TypeNode[]\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (\n          node === null ||\n          (START_NODE_ROW === node.row && START_NODE_COL === node.col) ||\n          (END_NODE_ROW === node.row && END_NODE_COL === node.col)\n        ) {\n          return;\n        }\n        const domElement = document.getElementById(\n          `node-${node.row}-${node.col}`\n        );\n        if (domElement !== null) {\n          domElement.className = \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n\n  const visualiseDijkstra = () => {\n    if (grid === undefined) return;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const endNode = grid[END_NODE_ROW][END_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n    console.log(visitedNodesInOrder);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  useEffect(() => {\n    const initialGrid = getInitialGrid();\n    setGrid(initialGrid);\n  }, []);\n  return (\n    <>\n      <div>\n        <button onClick={visualiseDijkstra}>Just do it</button>\n      </div>\n      <div className=\"grid\">\n        {grid?.map((row, rowIndex) => {\n          return (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, nodeIndex) => {\n                return <Components.Node key={nodeIndex} nodeObj={node} />;\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nexport default PathFindingVisualiser;\n","// Return value between min (inclusive) and max (exclusive)\nexport const getRandomInt = (min: number, max: number) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min);\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport PathFindingVisualiser from \"./PathFindingVisualiser\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualiser />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}