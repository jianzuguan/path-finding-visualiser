{"version":3,"sources":["utils/perlinNoise.ts","components/index.ts","components/Node.tsx","algorithms/dijkstra.ts","utils/createNode.ts","utils/controlParams.tsx","utils/getInitialGrid.ts","PathFindingVisualiser/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["perlin","components","Node","props","nodeObj","row","col","isStart","isEnd","weight","colourStyle","id","className","style","opacity","updateUnvisitedNeighbors","currentNode","grid","unvisitedNeighbors","node","neighbors","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","newDistance","distance","previousNode","dijkstra","stratNode","finishNode","unvisitedNodes","nodes","getAllNodes","visitedNodesInOrder","sort","nodeA","nodeB","closestNode","shift","Infinity","PERLIN_YWRAP","PERLIN_SIZE","perlin_octaves","perlin_amp_falloff","scaled_cosine","i","Math","cos","PI","noise","x","y","z","Array","random","rxf","ryf","n1","n2","n3","xi","floor","yi","zi","xf","yf","zf","r","ampl","o","of","createNode","startNodeRow","startNodeCol","endNodeRow","endNodeCol","getInitialGrid","numRows","numCols","NUM_ROWS","NUM_COLS","currentRow","PathFindingVisualiser","useState","setNumRows","setNumCols","setStartNodeRow","setStartNodeCol","setEndNodeRow","setEndNodeCol","instantShowResult","setInstantShowResult","setGrid","animateShortestPath","nodesInShortestPathOrder","setTimeout","domElement","document","getElementById","animateDijkstra","a","instantResult","useEffect","initialGrid","Button","variant","color","onClick","undefined","startNode","endNode","console","log","getNodesInShortestPathOrder","FormControlLabel","control","Checkbox","checked","onChange","e","target","name","label","TextField","type","value","Number","map","rowIndex","nodeIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.8a2d634a.chunk.js","sourcesContent":["//////////////////////////////////////////////////////////////\n\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/main/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\n\nconst PERLIN_YWRAPB = 4;\nconst PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\nconst PERLIN_ZWRAPB = 8;\nconst PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\nconst PERLIN_SIZE = 4095;\n\nlet perlin_octaves = 4; // default to medium smooth\nlet perlin_amp_falloff = 0.5; // 50% reduction/octave\n\nconst scaled_cosine = (i:number) => 0.5 * (1.0 - Math.cos(i * Math.PI));\n\nlet perlin:number[] | undefined; // will be initialized lazily by noise() or noiseSeed()\n\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin noise is\n * a random sequence generator producing a more naturally ordered, harmonic\n * succession of numbers compared to the standard <b>random()</b> function.\n * It was invented by Ken Perlin in the 1980s and been used since in\n * graphical applications to produce procedural textures, natural motion,\n * shapes, terrains etc.<br /><br /> The main difference to the\n * <b>random()</b> function is that Perlin noise is defined in an infinite\n * n-dimensional space where each pair of coordinates corresponds to a\n * fixed semi-random value (fixed only for the lifespan of the program; see\n * the <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function). p5.js can compute 1D, 2D and 3D noise,\n * depending on the number of coordinates given. The resulting value will\n * always be between 0.0 and 1.0. The noise value can be animated by moving\n * through the noise space as demonstrated in the example above. The 2nd\n * and 3rd dimension can also be interpreted as time.<br /><br />The actual\n * noise is structured similar to an audio signal, in respect to the\n * function's use of frequencies. Similar to the concept of harmonics in\n * physics, perlin noise is computed over several octaves which are added\n * together for the final result. <br /><br />Another way to adjust the\n * character of the resulting sequence is the scale of the input\n * coordinates. As the function works within an infinite space the value of\n * the coordinates doesn't matter as such, only the distance between\n * successive coordinates does (eg. when using <b>noise()</b> within a\n * loop). As a general rule the smaller the difference between coordinates,\n * the smoother the resulting noise sequence will be. Steps of 0.005-0.03\n * work best for most applications, but this will differ depending on use.\n *\n * @method noise\n * @param  {Number} x   x-coordinate in noise space\n * @param  {Number} [y] y-coordinate in noise space\n * @param  {Number} [z] z-coordinate in noise space\n * @return {Number}     Perlin noise value (between 0 and 1) at specified\n *                      coordinates\n * @example\n * <div>\n * <code>\n * let xoff = 0.0;\n *\n * function draw() {\n *   background(204);\n *   xoff = xoff + 0.01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n * <div>\n * <code>let noiseScale=0.02;\n *\n * function draw() {\n *   background(0);\n *   for (let x=0; x < width; x++) {\n *     let noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);\n *     stroke(noiseVal*255);\n *     line(x, mouseY+noiseVal*80, x, height);\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical line moves left to right with updating noise values.\n * horizontal wave pattern effected by mouse x-position & updating noise values.\n */\n\nexport const noise = function (x:number, y = 0, z = 0) {\n  if (perlin == null) {\n    perlin = new Array(PERLIN_SIZE + 1);\n    for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = Math.random();\n    }\n  }\n\n  if (x < 0) {\n    x = -x;\n  }\n  if (y < 0) {\n    y = -y;\n  }\n  if (z < 0) {\n    z = -z;\n  }\n\n  let xi = Math.floor(x),\n    yi = Math.floor(y),\n    zi = Math.floor(z);\n  let xf = x - xi;\n  let yf = y - yi;\n  let zf = z - zi;\n  let rxf, ryf;\n\n  let r = 0;\n  let ampl = 0.5;\n\n  let n1, n2, n3;\n\n  for (let o = 0; o < perlin_octaves; o++) {\n    let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n\n    rxf = scaled_cosine(xf);\n    ryf = scaled_cosine(yf);\n\n    n1 = perlin[of & PERLIN_SIZE];\n    n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);\n    n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n    n1 += ryf * (n2 - n1);\n\n    of += PERLIN_ZWRAP;\n    n2 = perlin[of & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);\n    n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n    n2 += ryf * (n3 - n2);\n\n    n1 += scaled_cosine(zf) * (n2 - n1);\n\n    r += n1 * ampl;\n    ampl *= perlin_amp_falloff;\n    xi <<= 1;\n    xf *= 2;\n    yi <<= 1;\n    yf *= 2;\n    zi <<= 1;\n    zf *= 2;\n\n    if (xf >= 1.0) {\n      xi++;\n      xf--;\n    }\n    if (yf >= 1.0) {\n      yi++;\n      yf--;\n    }\n    if (zf >= 1.0) {\n      zi++;\n      zf--;\n    }\n  }\n  return r;\n};\n\n/**\n *\n * Adjusts the character and level of detail produced by the Perlin noise\n * function. Similar to harmonics in physics, noise is computed over\n * several octaves. Lower octaves contribute more to the output signal and\n * as such define the overall intensity of the noise, whereas higher octaves\n * create finer grained details in the noise sequence.\n *\n * By default, noise is computed over 4 octaves with each octave contributing\n * exactly half than its predecessor, starting at 50% strength for the 1st\n * octave. This falloff amount can be changed by adding an additional function\n * parameter. Eg. a falloff factor of 0.75 means each octave will now have\n * 75% impact (25% less) of the previous lower octave. Any value between\n * 0.0 and 1.0 is valid, however note that values greater than 0.5 might\n * result in greater than 1.0 values returned by <b>noise()</b>.\n *\n * By changing these parameters, the signal created by the <b>noise()</b>\n * function can be adapted to fit very specific needs and characteristics.\n *\n * @method noiseDetail\n * @param {Number} lod number of octaves to be used by the noise\n * @param {Number} falloff falloff factor for each octave\n * @example\n * <div>\n * <code>\n * let noiseVal;\n * let noiseScale = 0.02;\n *\n * function setup() {\n *   createCanvas(100, 100);\n * }\n *\n * function draw() {\n *   background(0);\n *   for (let y = 0; y < height; y++) {\n *     for (let x = 0; x < width / 2; x++) {\n *       noiseDetail(2, 0.2);\n *       noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n *       stroke(noiseVal * 255);\n *       point(x, y);\n *       noiseDetail(8, 0.65);\n *       noiseVal = noise(\n *         (mouseX + x + width / 2) * noiseScale,\n *         (mouseY + y) * noiseScale\n *       );\n *       stroke(noiseVal * 255);\n *       point(x + width / 2, y);\n *     }\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * 2 vertical grey smokey patterns affected my mouse x-position and noise.\n */\nexport const noiseDetail = function (lod:number, falloff:number) {\n  if (lod > 0) {\n    perlin_octaves = lod;\n  }\n  if (falloff > 0) {\n    perlin_amp_falloff = falloff;\n  }\n};\n\n/**\n * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>\n * produces different results each time the program is run. Set the\n * <b>value</b> parameter to a constant to return the same pseudo-random\n * numbers each time the software is run.\n *\n * @method noiseSeed\n * @param {Number} seed   the seed value\n * @example\n * <div>\n * <code>let xoff = 0.0;\n *\n * function setup() {\n *   noiseSeed(99);\n *   stroke(0, 10);\n * }\n *\n * function draw() {\n *   xoff = xoff + .01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical grey lines drawing in pattern affected by noise.\n */\nexport const noiseSeed = function (seed: number) {\n  // Linear Congruential Generator\n  // Variant of a Lehman Generator\n  const lcg = (() => {\n    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n    // m is basically chosen to be large (as it is the max period)\n    // and for its relationships to a and c\n    const m = 4294967296;\n    // a - 1 should be divisible by m's prime factors\n    const a = 1664525;\n    // c and m should be co-prime\n    const c = 1013904223;\n    let seed: number, z:number;\n    return {\n      setSeed(val:number) {\n        // pick a random seed if val is undefined or null\n        // the >>> 0 casts the seed to an unsigned 32-bit integer\n        z = seed = (val == null ? Math.random() * m : val) >>> 0;\n      },\n      getSeed() {\n        return seed;\n      },\n      rand() {\n        // define the recurrence relationship\n        z = (a * z + c) % m;\n        // return a float in [0, 1)\n        // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n        return z / m;\n      },\n    };\n  })();\n\n  lcg.setSeed(seed);\n  perlin = new Array(PERLIN_SIZE + 1);\n  for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n    perlin[i] = lcg.rand();\n  }\n};\n","import Node from \"./Node\";\n\nconst components = {\n  Node,\n};\n\nexport default components;\n","import \"./Node.css\";\nimport TypeNode from \"../types/Node\";\n\ninterface Props {\n  nodeObj: TypeNode;\n}\n\nconst Node = (props: Props) => {\n  const { row, col, isStart, isEnd, weight } = props.nodeObj;\n\n  const colourStyle = isStart ? \"node-start\" : isEnd ? \"node-end\" : \"\";\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${colourStyle}`}\n      style={{ opacity: weight }}\n    >\n      {/* {weight} */}\n    </div>\n  );\n};\n\nexport default Node;\n","import TypeNode from \"../types/Node\";\n\nconst getAllNodes = (grid: TypeNode[][]) => {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nconst sortNodesByDistance = (unvisitedNoes: TypeNode[]) => {\n  unvisitedNoes.sort(\n    (nodeA: TypeNode, nodeB: TypeNode) => nodeA.distance - nodeB.distance\n  );\n};\n\nconst getUnvisitedNeighbors = (node: TypeNode, grid: TypeNode[][]) => {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};\n\nconst updateUnvisitedNeighbors = (\n  currentNode: TypeNode,\n  grid: TypeNode[][]\n) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const newDistance= currentNode.distance + neighbor.weight;\n    if (newDistance < neighbor.distance) {\n      neighbor.distance = newDistance;\n      neighbor.previousNode = currentNode;\n    }\n  }\n};\n\nconst dijkstra = (\n  grid: TypeNode[][],\n  stratNode: TypeNode,\n  finishNode: TypeNode\n) => {\n  const unvisitedNodes = getAllNodes(grid);\n  stratNode.distance = 0;\n  const visitedNodesInOrder = [];\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (!closestNode) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n\n  return visitedNodesInOrder;\n};\n\nexport const getNodesInShortestPathOrder = (endNode: TypeNode) => {\n  const nodesInShortestPathOrder = [];\n  let currentNode: TypeNode | null = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport default dijkstra;\n","import {\n  NOISE_ZOOM,\n  NOISE_OFFSET_COL,\n  NOISE_OFFSET_ROW,\n} from \"./controlParams\";\nimport { noise } from \"./perlinNoise\";\nimport TypeNode from \"../types/Node\";\n\nconst createNode = (\n  col: number,\n  row: number,\n  startNodeRow: number,\n  startNodeCol: number,\n  endNodeRow: number,\n  endNodeCol: number\n): TypeNode => {\n  return {\n    col,\n    row,\n    isStart: startNodeCol === col && startNodeRow === row,\n    isEnd: endNodeCol === col && endNodeRow === row,\n    weight: noise(\n      col * NOISE_ZOOM + NOISE_OFFSET_COL,\n      row * NOISE_ZOOM + NOISE_OFFSET_ROW\n    ),\n    distance: Infinity,\n    isVisited: false,\n    previousNode: null,\n  };\n};\n\nexport default createNode;\n","export const NUM_ROWS = 32;\nexport const NUM_COLS = 64;\nexport const START_NODE_ROW = 10;\nexport const START_NODE_COL = 10;\nexport const END_NODE_ROW = NUM_ROWS - 10;\nexport const END_NODE_COL = NUM_COLS - 10;\nexport const NOISE_ZOOM = 0.25;\nexport const NOISE_OFFSET_ROW = 100;\nexport const NOISE_OFFSET_COL = 10;\n","import {\n  NUM_ROWS,\n  NUM_COLS,\n  START_NODE_ROW,\n  START_NODE_COL,\n  END_NODE_ROW,\n  END_NODE_COL,\n} from \"./controlParams\";\nimport TypeNode from \"../types/Node\";\nimport createNode from \"./createNode\";\n\nconst getInitialGrid = (\n  numRows = NUM_ROWS,\n  numCols = NUM_COLS,\n  startNodeRow = START_NODE_ROW,\n  startNodeCol = START_NODE_COL,\n  endNodeRow = END_NODE_ROW,\n  endNodeCol = END_NODE_COL\n) => {\n  const grid: TypeNode[][] = [];\n  for (let row = 0; row < numRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < numCols; col++) {\n      currentRow.push(\n        createNode(col, row, startNodeRow, startNodeCol, endNodeRow, endNodeCol)\n      );\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nexport default getInitialGrid;\n","import { useEffect, useState } from \"react\";\nimport {\n  Checkbox,\n  Button,\n  FormControlLabel,\n  TextField,\n} from \"@material-ui/core\";\nimport TypeNode from \"../types/Node\";\nimport Components from \"../components\";\nimport dijkstra, { getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\nimport \"./index.css\";\nimport {\n  NUM_ROWS,\n  NUM_COLS,\n  START_NODE_ROW,\n  START_NODE_COL,\n  END_NODE_ROW,\n  END_NODE_COL,\n} from \"../utils/controlParams\";\nimport getInitialGrid from \"../utils/getInitialGrid\";\n\nconst PathFindingVisualiser = () => {\n  const [numRows, setNumRows] = useState(NUM_ROWS);\n  const [numCols, setNumCols] = useState(NUM_COLS);\n  const [startNodeRow, setStartNodeRow] = useState(START_NODE_ROW);\n  const [startNodeCol, setStartNodeCol] = useState(START_NODE_COL);\n  const [endNodeRow, setEndNodeRow] = useState(END_NODE_ROW);\n  const [endNodeCol, setEndNodeCol] = useState(END_NODE_COL);\n  const [instantShowResult, setInstantShowResult] = useState(true);\n\n  const [grid, setGrid] = useState<TypeNode[][]>();\n\n  const animateShortestPath = (nodesInShortestPathOrder: TypeNode[]) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (\n          node === null ||\n          (startNodeRow === node.row && startNodeCol === node.col) ||\n          (endNodeRow === node.row && endNodeCol === node.col)\n        ) {\n          return;\n        }\n        const domElement = document.getElementById(\n          `node-${node.row}-${node.col}`\n        );\n        if (domElement === null) {\n          return;\n        }\n        domElement.className = \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const animateDijkstra = async (\n    visitedNodesInOrder: TypeNode[],\n    nodesInShortestPathOrder: TypeNode[]\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 100 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (\n          node === null ||\n          (startNodeRow === node.row && startNodeCol === node.col) ||\n          (endNodeRow === node.row && endNodeCol === node.col)\n        ) {\n          return;\n        }\n        const domElement = document.getElementById(\n          `node-${node.row}-${node.col}`\n        );\n        if (domElement !== null) {\n          domElement.className = \"node node-visited\";\n        }\n      }, 100 * i);\n    }\n  };\n\n  const instantResult = async (\n    visitedNodesInOrder: TypeNode[],\n    nodesInShortestPathOrder: TypeNode[]\n  ) => {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      const node = visitedNodesInOrder[i];\n      if (\n        node === null ||\n        (startNodeRow === node.row && startNodeCol === node.col) ||\n        (endNodeRow === node.row && endNodeCol === node.col)\n      ) {\n        continue;\n      }\n      const domElement = document.getElementById(\n        `node-${node.row}-${node.col}`\n      );\n      if (domElement !== null) {\n        domElement.className = \"node node-visited\";\n      }\n    }\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      const node = nodesInShortestPathOrder[i];\n      if (\n        node === null ||\n        (startNodeRow === node.row && startNodeCol === node.col) ||\n        (endNodeRow === node.row && endNodeCol === node.col)\n      ) {\n        continue;\n      }\n      const domElement = document.getElementById(\n        `node-${node.row}-${node.col}`\n      );\n      if (domElement === null) {\n        continue;\n      }\n      domElement.className = \"node node-shortest-path\";\n    }\n  };\n\n  const visualiseDijkstra = () => {\n    if (grid === undefined) return;\n    const startNode = grid[startNodeRow][startNodeCol];\n    const endNode = grid[endNodeRow][endNodeCol];\n    const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n    console.log(visitedNodesInOrder);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    if (instantShowResult) {\n      instantResult(visitedNodesInOrder, nodesInShortestPathOrder);\n    } else {\n      animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  };\n\n  useEffect(() => {\n    const initialGrid = getInitialGrid();\n    setGrid(initialGrid);\n  }, []);\n\n  useEffect(() => {\n    const initialGrid = getInitialGrid(\n      numRows,\n      numCols,\n      startNodeRow,\n      startNodeCol,\n      endNodeRow,\n      endNodeCol\n    );\n    setGrid(initialGrid);\n  }, [numRows, numCols, startNodeRow, startNodeCol, endNodeRow, endNodeCol]);\n\n  return (\n    <>\n      <div className=\"side-bar\">\n        <Button variant=\"contained\" color=\"primary\" onClick={visualiseDijkstra}>\n          Just do it\n        </Button>\n        <FormControlLabel\n          control={\n            <Checkbox\n              checked={instantShowResult}\n              onChange={(e) => setInstantShowResult(e.target.checked)}\n              name=\"instant-show-result-checkbox\"\n              color=\"primary\"\n            />\n          }\n          label=\"Instant show result\"\n        />\n        <TextField\n          variant=\"outlined\"\n          type=\"number\"\n          id=\"number-of-rows-text-field\"\n          label=\"Number of Rows\"\n          value={numRows}\n          onChange={(e) => setNumRows(Number(e.target.value) || NUM_ROWS)}\n        />\n\n        <TextField\n          variant=\"outlined\"\n          type=\"number\"\n          id=\"number-of-cols-text-field\"\n          label=\"Number of col\"\n          value={numCols}\n          onChange={(e) => setNumCols(Number(e.target.value) || NUM_COLS)}\n        />\n\n        <TextField\n          variant=\"outlined\"\n          type=\"number\"\n          id=\"start-node-row-text-field\"\n          label=\"Start Node Row\"\n          value={startNodeRow}\n          onChange={(e) => setStartNodeRow(Number(e.target.value) || 1)}\n        />\n\n        <TextField\n          variant=\"outlined\"\n          type=\"number\"\n          id=\"start-node-col-text-field\"\n          label=\"Start Node Col\"\n          value={startNodeCol}\n          onChange={(e) => setStartNodeCol(Number(e.target.value) || 1)}\n        />\n\n        <TextField\n          variant=\"outlined\"\n          type=\"number\"\n          id=\"end-node-row-text-field\"\n          label=\"End Node Row\"\n          value={endNodeRow}\n          onChange={(e) => setEndNodeRow(Number(e.target.value) || 1)}\n        />\n\n        <TextField\n          variant=\"outlined\"\n          type=\"number\"\n          id=\"end-node-col-text-field\"\n          label=\"End Node Col\"\n          value={endNodeCol}\n          onChange={(e) => setEndNodeCol(Number(e.target.value) || 1)}\n        />\n      </div>\n      <div className=\"grid\">\n        {grid?.map((row, rowIndex) => {\n          return (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, nodeIndex) => {\n                return <Components.Node key={nodeIndex} nodeObj={node} />;\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nexport default PathFindingVisualiser;\n","import React from \"react\";\nimport \"./App.css\";\nimport PathFindingVisualiser from \"./PathFindingVisualiser\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualiser />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}