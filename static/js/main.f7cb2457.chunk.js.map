{"version":3,"sources":["utils/perlinNoise.ts","components/index.ts","components/Node.tsx","utils/controlParams.ts","redux/hooks.ts","redux/reducers/controlSlice.ts","PathFindingVisualiser/ControlPanel.tsx","algorithms/dijkstra.ts","utils/createNode.ts","utils/getInitialGrid.ts","redux/reducers/gridSlice.ts","PathFindingVisualiser/index.tsx","redux/store.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["perlin","components","Node","props","nodeObj","row","y","col","x","weight","colourStyle","isStart","isFinish","isInShortestPath","isVisited","id","className","style","opacity","NOISE_ZOOM","useAppDispatch","useDispatch","useAppSelector","useSelector","initialState","numRows","numCols","startNodeX","startNodeY","finishNodeX","NUM_COLS","finishNodeY","NUM_ROWS","noiseOffsetX","noiseOffsetY","instantShowResult","controlsSlice","createSlice","name","reducers","setNumRows","state","action","payload","setNumCols","setStartNodeX","setStartNodeY","setFinishNodeX","setFinishNodeY","setNoiseOffsetX","setNoiseOffsetY","setInstantShowResult","ControlPanel","dispatch","controls","FormControlLabel","control","Checkbox","checked","onChange","e","actions","target","color","label","TextField","variant","type","value","Number","getAllUnvisitedNode","grid","unvisitedNodes","node","push","sortNodesByDistance","unvisitedNoes","sort","nodeA","nodeB","distance","init","gridClone","map","length","hasVisitedFinishNode","hasNext","closestNode","shift","Infinity","next","gridNode","currentNode","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","newDistance","previousNode","updateUnvisitedNeighbors","initShortestPathTrace","hasNextPathNode","nextPathNode","PERLIN_YWRAP","PERLIN_SIZE","perlin_octaves","perlin_amp_falloff","scaled_cosine","i","Math","cos","PI","noise","z","Array","random","rxf","ryf","n1","n2","n3","xi","floor","yi","zi","xf","yf","zf","r","ampl","o","of","createNode","useNoise","getInitialGrid","currentRow","gridSlice","isSearching","isTracing","setGrid","setIsSearching","setIsTracing","PathFindingVisualiser","intervalRef","useRef","useEffect","initialGrid","hasFinishSearching","hasNextStep","undefined","current","clearInterval","setTimeout","nextGrid","Button","onClick","currentGrid","rowIndex","nodeIndex","store","configureStore","reducer","controlsReducer","App","reduxStore","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f7cb2457.chunk.js","sourcesContent":["//////////////////////////////////////////////////////////////\n\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/main/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\n\nconst PERLIN_YWRAPB = 4;\nconst PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\nconst PERLIN_ZWRAPB = 8;\nconst PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\nconst PERLIN_SIZE = 4095;\n\nlet perlin_octaves = 4; // default to medium smooth\nlet perlin_amp_falloff = 0.5; // 50% reduction/octave\n\nconst scaled_cosine = (i: number) => 0.5 * (1.0 - Math.cos(i * Math.PI));\n\nlet perlin: number[] | undefined; // will be initialized lazily by noise() or noiseSeed()\n\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin noise is\n * a random sequence generator producing a more naturally ordered, harmonic\n * succession of numbers compared to the standard <b>random()</b> function.\n * It was invented by Ken Perlin in the 1980s and been used since in\n * graphical applications to produce procedural textures, natural motion,\n * shapes, terrains etc.<br /><br /> The main difference to the\n * <b>random()</b> function is that Perlin noise is defined in an infinite\n * n-dimensional space where each pair of coordinates corresponds to a\n * fixed semi-random value (fixed only for the lifespan of the program; see\n * the <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function). p5.js can compute 1D, 2D and 3D noise,\n * depending on the number of coordinates given. The resulting value will\n * always be between 0.0 and 1.0. The noise value can be animated by moving\n * through the noise space as demonstrated in the example above. The 2nd\n * and 3rd dimension can also be interpreted as time.<br /><br />The actual\n * noise is structured similar to an audio signal, in respect to the\n * function's use of frequencies. Similar to the concept of harmonics in\n * physics, perlin noise is computed over several octaves which are added\n * together for the final result. <br /><br />Another way to adjust the\n * character of the resulting sequence is the scale of the input\n * coordinates. As the function works within an infinite space the value of\n * the coordinates doesn't matter as such, only the distance between\n * successive coordinates does (eg. when using <b>noise()</b> within a\n * loop). As a general rule the smaller the difference between coordinates,\n * the smoother the resulting noise sequence will be. Steps of 0.005-0.03\n * work best for most applications, but this will differ depending on use.\n *\n * @method noise\n * @param  {Number} x   x-coordinate in noise space\n * @param  {Number} [y] y-coordinate in noise space\n * @param  {Number} [z] z-coordinate in noise space\n * @return {Number}     Perlin noise value (between 0 and 1) at specified\n *                      coordinates\n * @example\n * <div>\n * <code>\n * let xoff = 0.0;\n *\n * function draw() {\n *   background(204);\n *   xoff = xoff + 0.01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n * <div>\n * <code>let noiseScale=0.02;\n *\n * function draw() {\n *   background(0);\n *   for (let x=0; x < width; x++) {\n *     let noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);\n *     stroke(noiseVal*255);\n *     line(x, mouseY+noiseVal*80, x, height);\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical line moves left to right with updating noise values.\n * horizontal wave pattern effected by mouse x-position & updating noise values.\n */\n\nexport const noise = function (x: number, y = 0, z = 0) {\n  if (perlin == null) {\n    perlin = new Array(PERLIN_SIZE + 1);\n    for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = Math.random();\n    }\n  }\n\n  if (x < 0) {\n    x = -x;\n  }\n  if (y < 0) {\n    y = -y;\n  }\n  if (z < 0) {\n    z = -z;\n  }\n\n  let xi = Math.floor(x),\n    yi = Math.floor(y),\n    zi = Math.floor(z);\n  let xf = x - xi;\n  let yf = y - yi;\n  let zf = z - zi;\n  let rxf, ryf;\n\n  let r = 0;\n  let ampl = 0.5;\n\n  let n1, n2, n3;\n\n  for (let o = 0; o < perlin_octaves; o++) {\n    let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n\n    rxf = scaled_cosine(xf);\n    ryf = scaled_cosine(yf);\n\n    n1 = perlin[of & PERLIN_SIZE];\n    n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);\n    n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n    n1 += ryf * (n2 - n1);\n\n    of += PERLIN_ZWRAP;\n    n2 = perlin[of & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);\n    n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n    n2 += ryf * (n3 - n2);\n\n    n1 += scaled_cosine(zf) * (n2 - n1);\n\n    r += n1 * ampl;\n    ampl *= perlin_amp_falloff;\n    xi <<= 1;\n    xf *= 2;\n    yi <<= 1;\n    yf *= 2;\n    zi <<= 1;\n    zf *= 2;\n\n    if (xf >= 1.0) {\n      xi++;\n      xf--;\n    }\n    if (yf >= 1.0) {\n      yi++;\n      yf--;\n    }\n    if (zf >= 1.0) {\n      zi++;\n      zf--;\n    }\n  }\n  return r;\n};\n\n/**\n *\n * Adjusts the character and level of detail produced by the Perlin noise\n * function. Similar to harmonics in physics, noise is computed over\n * several octaves. Lower octaves contribute more to the output signal and\n * as such define the overall intensity of the noise, whereas higher octaves\n * create finer grained details in the noise sequence.\n *\n * By default, noise is computed over 4 octaves with each octave contributing\n * exactly half than its predecessor, starting at 50% strength for the 1st\n * octave. This falloff amount can be changed by adding an additional function\n * parameter. Eg. a falloff factor of 0.75 means each octave will now have\n * 75% impact (25% less) of the previous lower octave. Any value between\n * 0.0 and 1.0 is valid, however note that values greater than 0.5 might\n * result in greater than 1.0 values returned by <b>noise()</b>.\n *\n * By changing these parameters, the signal created by the <b>noise()</b>\n * function can be adapted to fit very specific needs and characteristics.\n *\n * @method noiseDetail\n * @param {Number} lod number of octaves to be used by the noise\n * @param {Number} falloff falloff factor for each octave\n * @example\n * <div>\n * <code>\n * let noiseVal;\n * let noiseScale = 0.02;\n *\n * function setup() {\n *   createCanvas(100, 100);\n * }\n *\n * function draw() {\n *   background(0);\n *   for (let y = 0; y < height; y++) {\n *     for (let x = 0; x < width / 2; x++) {\n *       noiseDetail(2, 0.2);\n *       noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n *       stroke(noiseVal * 255);\n *       point(x, y);\n *       noiseDetail(8, 0.65);\n *       noiseVal = noise(\n *         (mouseX + x + width / 2) * noiseScale,\n *         (mouseY + y) * noiseScale\n *       );\n *       stroke(noiseVal * 255);\n *       point(x + width / 2, y);\n *     }\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * 2 vertical grey smokey patterns affected my mouse x-position and noise.\n */\nexport const noiseDetail = function (lod: number, falloff: number) {\n  if (lod > 0) {\n    perlin_octaves = lod;\n  }\n  if (falloff > 0) {\n    perlin_amp_falloff = falloff;\n  }\n};\n\n/**\n * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>\n * produces different results each time the program is run. Set the\n * <b>value</b> parameter to a constant to return the same pseudo-random\n * numbers each time the software is run.\n *\n * @method noiseSeed\n * @param {Number} seed   the seed value\n * @example\n * <div>\n * <code>let xoff = 0.0;\n *\n * function setup() {\n *   noiseSeed(99);\n *   stroke(0, 10);\n * }\n *\n * function draw() {\n *   xoff = xoff + .01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical grey lines drawing in pattern affected by noise.\n */\nexport const noiseSeed = function (seed: number) {\n  // Linear Congruential Generator\n  // Variant of a Lehman Generator\n  const lcg = (() => {\n    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n    // m is basically chosen to be large (as it is the max period)\n    // and for its relationships to a and c\n    const m = 4294967296;\n    // a - 1 should be divisible by m's prime factors\n    const a = 1664525;\n    // c and m should be co-prime\n    const c = 1013904223;\n    let seed: number, z: number;\n    return {\n      setSeed(val: number) {\n        // pick a random seed if val is undefined or null\n        // the >>> 0 casts the seed to an unsigned 32-bit integer\n        z = seed = (val == null ? Math.random() * m : val) >>> 0;\n      },\n      getSeed() {\n        return seed;\n      },\n      rand() {\n        // define the recurrence relationship\n        z = (a * z + c) % m;\n        // return a float in [0, 1)\n        // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n        return z / m;\n      },\n    };\n  })();\n\n  lcg.setSeed(seed);\n  perlin = new Array(PERLIN_SIZE + 1);\n  for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n    perlin[i] = lcg.rand();\n  }\n};\n","import Node from 'components/Node';\n\nconst components = {\n  Node,\n};\n\nexport default components;\n","import 'components/Node.css';\nimport TypeNode from 'types/Node';\n\ninterface Props {\n  nodeObj: TypeNode;\n}\n\nconst calculateClassName = (nodeObj: TypeNode) => {\n  if (nodeObj.isStart) return 'node node-start';\n  if (nodeObj.isFinish) return 'node node-finish';\n  if (nodeObj.isInShortestPath) return 'node node-shortest-path';\n  if (nodeObj.isVisited) return 'node node-visited';\n\n  return 'node';\n};\n\nconst Node = (props: Props) => {\n  const { y: row, x: col, weight } = props.nodeObj;\n\n  const colourStyle = calculateClassName(props.nodeObj);\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={colourStyle}\n      style={{ opacity: weight }}\n    >\n      {/* {weight} */}\n    </div>\n  );\n};\n\nexport default Node;\n","export const NUM_ROWS = 32;\nexport const NUM_COLS = 64;\nexport const START_NODE_X = 10;\nexport const START_NODE_Y = 10;\nexport const FINISH_NODE_X = NUM_COLS - 10;\nexport const FINISH_NODE_Y = NUM_ROWS - 10;\nexport const NOISE_ZOOM = 0.25;\nexport const NOISE_OFFSET_X = 10;\nexport const NOISE_OFFSET_Y = 100;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from 'redux/store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport * as controlsParams from 'utils/controlParams';\n\n// Define a type for the slice state\ninterface controlsState {\n  numRows: number;\n  numCols: number;\n  startNodeX: number;\n  startNodeY: number;\n  finishNodeX: number;\n  finishNodeY: number;\n  noiseOffsetX: number;\n  noiseOffsetY: number;\n  instantShowResult: boolean;\n}\n\n// Define the initial state using that type\nconst initialState: controlsState = {\n  numRows: controlsParams.NUM_ROWS,\n  numCols: controlsParams.NUM_COLS,\n  startNodeX: controlsParams.START_NODE_X,\n  startNodeY: controlsParams.START_NODE_Y,\n  finishNodeX: controlsParams.FINISH_NODE_X,\n  finishNodeY: controlsParams.FINISH_NODE_Y,\n  noiseOffsetX: controlsParams.NOISE_OFFSET_X,\n  noiseOffsetY: controlsParams.NOISE_OFFSET_Y,\n  instantShowResult: true,\n};\n\nexport const controlsSlice = createSlice({\n  name: 'controls',\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState,\n  reducers: {\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    setNumRows: (state, action: PayloadAction<number>) => {\n      state.numRows = action.payload;\n    },\n    setNumCols: (state, action: PayloadAction<number>) => {\n      state.numCols = action.payload;\n    },\n    setStartNodeX: (state, action: PayloadAction<number>) => {\n      state.startNodeX = action.payload;\n    },\n    setStartNodeY: (state, action: PayloadAction<number>) => {\n      state.startNodeY = action.payload;\n    },\n    setFinishNodeX: (state, action: PayloadAction<number>) => {\n      state.finishNodeX = action.payload;\n    },\n    setFinishNodeY: (state, action: PayloadAction<number>) => {\n      state.finishNodeY = action.payload;\n    },\n    setNoiseOffsetX: (state, action: PayloadAction<number>) => {\n      state.noiseOffsetX = action.payload;\n    },\n    setNoiseOffsetY: (state, action: PayloadAction<number>) => {\n      state.noiseOffsetY = action.payload;\n    },\n    setInstantShowResult: (state, action: PayloadAction<boolean>) => {\n      state.instantShowResult = action.payload;\n    },\n  },\n});\n\nexport default controlsSlice.reducer;\n","import { Checkbox, FormControlLabel, TextField } from '@material-ui/core';\nimport { NUM_COLS, NUM_ROWS } from 'utils/controlParams';\nimport { RootState } from 'redux/store';\nimport { useAppDispatch, useAppSelector } from 'redux/hooks';\nimport { controlsSlice } from 'redux/reducers/controlSlice';\n\nconst ControlPanel = () => {\n  const dispatch = useAppDispatch();\n\n  const instantShowResult = useAppSelector(\n    (state: RootState) => state.controls.instantShowResult\n  );\n  const numRows = useAppSelector((state: RootState) => state.controls.numRows);\n  const numCols = useAppSelector((state: RootState) => state.controls.numCols);\n  const startNodeX = useAppSelector(\n    (state: RootState) => state.controls.startNodeX\n  );\n  const startNodeY = useAppSelector(\n    (state: RootState) => state.controls.startNodeY\n  );\n  const finishNodeX = useAppSelector(\n    (state: RootState) => state.controls.finishNodeX\n  );\n  const finishNodeY = useAppSelector(\n    (state: RootState) => state.controls.finishNodeY\n  );\n\n  return (\n    <>\n      <FormControlLabel\n        control={\n          <Checkbox\n            checked={instantShowResult}\n            onChange={(e) =>\n              dispatch(\n                controlsSlice.actions.setInstantShowResult(e.target.checked)\n              )\n            }\n            name=\"instant-show-result-checkbox\"\n            color=\"primary\"\n          />\n        }\n        label=\"Instant show result\"\n      />\n      <TextField\n        variant=\"outlined\"\n        type=\"number\"\n        id=\"number-of-rows-text-field\"\n        label=\"Number of Rows\"\n        value={numRows}\n        onChange={(e) =>\n          dispatch(\n            controlsSlice.actions.setNumRows(Number(e.target.value) || NUM_ROWS)\n          )\n        }\n      />\n\n      <TextField\n        variant=\"outlined\"\n        type=\"number\"\n        id=\"number-of-cols-text-field\"\n        label=\"Number of col\"\n        value={numCols}\n        onChange={(e) =>\n          dispatch(\n            controlsSlice.actions.setNumCols(Number(e.target.value) || NUM_COLS)\n          )\n        }\n      />\n\n      <TextField\n        variant=\"outlined\"\n        type=\"number\"\n        id=\"start-node-row-text-field\"\n        label=\"Start Node Row\"\n        value={startNodeY}\n        onChange={(e) =>\n          dispatch(\n            controlsSlice.actions.setStartNodeY(Number(e.target.value) || 1)\n          )\n        }\n      />\n\n      <TextField\n        variant=\"outlined\"\n        type=\"number\"\n        id=\"start-node-col-text-field\"\n        label=\"Start Node Col\"\n        value={startNodeX}\n        onChange={(e) =>\n          dispatch(\n            controlsSlice.actions.setStartNodeX(Number(e.target.value) || 1)\n          )\n        }\n      />\n\n      <TextField\n        variant=\"outlined\"\n        type=\"number\"\n        id=\"end-node-row-text-field\"\n        label=\"Finish Node Row\"\n        value={finishNodeY}\n        onChange={(e) =>\n          dispatch(\n            controlsSlice.actions.setFinishNodeY(Number(e.target.value) || 1)\n          )\n        }\n      />\n\n      <TextField\n        variant=\"outlined\"\n        type=\"number\"\n        id=\"end-node-col-text-field\"\n        label=\"Finish Node Col\"\n        value={finishNodeX}\n        onChange={(e) =>\n          dispatch(\n            controlsSlice.actions.setFinishNodeX(Number(e.target.value) || 1)\n          )\n        }\n      />\n    </>\n  );\n};\n\nexport default ControlPanel;\n","import TypeNode from 'types/Node';\n\nconst getAllUnvisitedNode = (grid: TypeNode[][]) => {\n  const unvisitedNodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      if (!node.isVisited) {\n        unvisitedNodes.push(node);\n      }\n    }\n  }\n  return unvisitedNodes;\n};\n\nconst sortNodesByDistance = (unvisitedNoes: TypeNode[]) => {\n  unvisitedNoes.sort(\n    (nodeA: TypeNode, nodeB: TypeNode) => nodeA.distance - nodeB.distance\n  );\n};\n\nconst getUnvisitedNeighbors = (node: TypeNode, grid: TypeNode[][]) => {\n  const neighbors = [];\n  const { x: col, y: row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};\n\nconst updateUnvisitedNeighbors = (\n  currentNode: TypeNode,\n  grid: TypeNode[][]\n) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const newDistance = currentNode.distance + neighbor.weight;\n    if (newDistance < neighbor.distance) {\n      neighbor.distance = newDistance;\n      neighbor.previousNode = currentNode;\n    }\n  }\n};\n\nexport const getNodesInShortestPathOrder = (finishNode: TypeNode) => {\n  const nodesInShortestPathOrder = [];\n  let currentNode: TypeNode | null = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport const init = (\n  grid: TypeNode[][],\n  startNodeX: number,\n  startNodeY: number\n): TypeNode[][] => {\n  const gridClone = [...grid].map((row) => [...row]);\n\n  if (\n    gridClone.length > startNodeY &&\n    gridClone[startNodeY].length > startNodeX\n  ) {\n    gridClone[startNodeY][startNodeX] = {\n      ...gridClone[startNodeY][startNodeX],\n      distance: 0,\n    };\n  }\n\n  return gridClone;\n};\n\nexport const hasVisitedFinishNode = (\n  grid: TypeNode[][],\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  if (finishNodeX < 0 || finishNodeY < 0) {\n    return false;\n  }\n\n  if (grid.length > finishNodeY && grid[finishNodeY].length > finishNodeX) {\n    return grid[finishNodeY][finishNodeX].isVisited;\n  }\n\n  return false;\n};\n\nexport const hasNext = (grid: TypeNode[][]) => {\n  const unvisitedNodes = getAllUnvisitedNode(grid);\n\n  sortNodesByDistance(unvisitedNodes);\n  const closestNode = unvisitedNodes.shift();\n  // All nodes in grid visited.\n  if (!closestNode) return false;\n  // All reachable nodes visited.\n  if (closestNode.distance === Infinity) return false;\n\n  return true;\n};\n\nexport const next = (grid: TypeNode[][]) => {\n  const gridClone = [...grid].map((row) =>\n    [...row].map(function (gridNode: TypeNode) {\n      return { ...gridNode };\n    })\n  );\n\n  const unvisitedNodes = getAllUnvisitedNode(gridClone);\n  sortNodesByDistance(unvisitedNodes);\n  let closestNode = unvisitedNodes.shift();\n  if (!closestNode) return gridClone;\n  closestNode.isVisited = true;\n  updateUnvisitedNeighbors(closestNode, gridClone);\n\n  return gridClone;\n};\n\nexport const initShortestPathTrace = (\n  grid: TypeNode[][],\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  const currentNode: TypeNode = grid[finishNodeY][finishNodeX];\n  if (currentNode.isVisited) {\n    return [...grid].map((row) =>\n      [...row].map(function (gridNode: TypeNode) {\n        if (gridNode.x === finishNodeX && gridNode.y === finishNodeY) {\n          return { ...gridNode, isInShortestPath: true };\n        }\n        return { ...gridNode };\n      })\n    );\n  }\n\n  return grid;\n};\n\nexport const hasNextPathNode = (\n  grid: TypeNode[][],\n  startNodeX: number,\n  startNodeY: number,\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  // Start from finish node and trace back.\n  let currentNode: TypeNode | null = grid[finishNodeY][finishNodeX];\n\n  while (currentNode?.isInShortestPath) {\n    // Node in shortest path means this node already been traced.\n    const previousNode: TypeNode | null = currentNode.previousNode;\n    if (previousNode === null) return grid;\n    currentNode = grid[previousNode.y][previousNode.x];\n  }\n  // Now the currentNode has not been marked as traced.\n\n  if (!currentNode || !currentNode.previousNode) {\n    return false;\n  }\n\n  const startNode: TypeNode = grid[startNodeY][startNodeX];\n  if (currentNode === startNode) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const nextPathNode = (\n  grid: TypeNode[][],\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  let currentNode: TypeNode | null = grid[finishNodeY][finishNodeX];\n  while (currentNode && currentNode.isInShortestPath) {\n    const previousNode: TypeNode | null = currentNode.previousNode;\n    if (previousNode === null) return grid;\n    currentNode = grid[previousNode.y][previousNode.x];\n  }\n\n  if (currentNode === null) return grid;\n\n  const { x, y } = currentNode;\n  return [...grid].map((row) =>\n    [...row].map(function (gridNode: TypeNode) {\n      if (gridNode.x === x && gridNode.y === y) {\n        const updatedNode = { ...gridNode, isInShortestPath: true };\n        return updatedNode;\n      }\n\n      return { ...gridNode };\n    })\n  );\n};\n","import {\n  NOISE_ZOOM,\n  NOISE_OFFSET_X,\n  NOISE_OFFSET_Y,\n} from 'utils/controlParams';\nimport { noise } from 'utils/perlinNoise';\nimport TypeNode from 'types/Node';\n\nconst createNode = (\n  x: number,\n  y: number,\n  startNodeX: number,\n  startNodeY: number,\n  finishNodeX: number,\n  finishNodeY: number,\n  useNoise: boolean = true\n): TypeNode => {\n  return {\n    x,\n    y,\n    isStart: startNodeX === x && startNodeY === y,\n    isFinish: finishNodeX === x && finishNodeY === y,\n    weight: useNoise\n      ? noise(x * NOISE_ZOOM + NOISE_OFFSET_X, y * NOISE_ZOOM + NOISE_OFFSET_Y)\n      : 1,\n    distance: Infinity,\n    isVisited: false,\n    isInShortestPath: false,\n    previousNode: null,\n  };\n};\n\nexport default createNode;\n","import {\n  NUM_ROWS,\n  NUM_COLS,\n  START_NODE_Y,\n  START_NODE_X,\n  FINISH_NODE_Y,\n  FINISH_NODE_X,\n} from 'utils/controlParams';\nimport TypeNode from 'types/Node';\nimport createNode from 'utils/createNode';\n\nconst getInitialGrid = (\n  numRows = NUM_ROWS,\n  numCols = NUM_COLS,\n  startNodeX = START_NODE_X,\n  startNodeY = START_NODE_Y,\n  finishNodeX = FINISH_NODE_X,\n  finishNodeY = FINISH_NODE_Y\n) => {\n  const grid: TypeNode[][] = [];\n  for (let row = 0; row < numRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < numCols; col++) {\n      currentRow.push(\n        createNode(col, row, startNodeX, startNodeY, finishNodeX, finishNodeY)\n      );\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nexport default getInitialGrid;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport TypeNode from 'types/Node';\n\n// Define a type for the slice state\ninterface gridState {\n  grid: TypeNode[][];\n  isSearching: boolean;\n  isTracing: boolean;\n}\n\n// Define the initial state using that type\nconst initialState: gridState = {\n  grid: [],\n  isSearching: false,\n  isTracing: false,\n};\n\nexport const gridSlice = createSlice({\n  name: 'grid',\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState,\n  reducers: {\n    setGrid: (state, action: PayloadAction<TypeNode[][]>) => {\n      state.grid = action.payload;\n    },\n    setIsSearching: (state, action: PayloadAction<boolean>) => {\n      state.isSearching = action.payload;\n    },\n    setIsTracing: (state, action: PayloadAction<boolean>) => {\n      state.isTracing = action.payload;\n    },\n  },\n});\n\nexport default gridSlice.reducer;\n","import { useEffect, useRef } from 'react';\nimport { Button } from '@material-ui/core';\nimport TypeNode from 'types/Node';\nimport Components from 'components';\nimport ControlPanel from 'PathFindingVisualiser/ControlPanel';\nimport './index.css';\nimport {\n  hasNext,\n  hasNextPathNode,\n  hasVisitedFinishNode,\n  init,\n  initShortestPathTrace,\n  next,\n  nextPathNode,\n} from 'algorithms/dijkstra';\nimport getInitialGrid from 'utils/getInitialGrid';\nimport { RootState } from 'redux/store';\nimport { useAppDispatch, useAppSelector } from 'redux/hooks';\nimport { gridSlice } from 'redux/reducers/gridSlice';\n\nconst PathFindingVisualiser = () => {\n  const dispatch = useAppDispatch();\n\n  const instantShowResult = useAppSelector(\n    (state: RootState) => state.controls.instantShowResult\n  );\n  const numRows = useAppSelector((state: RootState) => state.controls.numRows);\n  const numCols = useAppSelector((state: RootState) => state.controls.numCols);\n  const startNodeX = useAppSelector(\n    (state: RootState) => state.controls.startNodeX\n  );\n  const startNodeY = useAppSelector(\n    (state: RootState) => state.controls.startNodeY\n  );\n  const finishNodeX = useAppSelector(\n    (state: RootState) => state.controls.finishNodeX\n  );\n  const finishNodeY = useAppSelector(\n    (state: RootState) => state.controls.finishNodeY\n  );\n\n  const grid: TypeNode[][] = useAppSelector(\n    (state: RootState) => state.grid.grid\n  );\n\n  const isSearching: boolean = useAppSelector(\n    (state: RootState) => state.grid.isSearching\n  );\n  const isTracing: boolean = useAppSelector(\n    (state: RootState) => state.grid.isTracing\n  );\n\n  const intervalRef = useRef<NodeJS.Timeout>();\n\n  const start = () => {\n    if (!instantShowResult) {\n      dispatch(gridSlice.actions.setGrid(init(grid, startNodeX, startNodeY)));\n      dispatch(gridSlice.actions.setIsSearching(true));\n      return;\n    }\n\n    let currentGrid = init(grid, startNodeX, startNodeY);\n    while (\n      !hasVisitedFinishNode(currentGrid, finishNodeX, finishNodeY) &&\n      hasNext(currentGrid)\n    ) {\n      currentGrid = next(currentGrid);\n    }\n    currentGrid = initShortestPathTrace(currentGrid, finishNodeX, finishNodeY);\n    while (hasNextPathNode(currentGrid, startNodeX, startNodeY, finishNodeX, finishNodeY)) {\n      currentGrid = nextPathNode(currentGrid, finishNodeX, finishNodeY);\n    }\n\n    dispatch(gridSlice.actions.setGrid(currentGrid));\n  };\n\n  // Page loaded and generate a grid.\n  useEffect(() => {\n    const initialGrid = getInitialGrid();\n    dispatch(gridSlice.actions.setGrid(initialGrid));\n  }, [dispatch]);\n\n  // Reset and regenerate the grid.\n  useEffect(() => {\n    const initialGrid = getInitialGrid(\n      numRows,\n      numCols,\n      startNodeX,\n      startNodeY,\n      finishNodeX,\n      finishNodeY\n    );\n    dispatch(gridSlice.actions.setIsSearching(false));\n    dispatch(gridSlice.actions.setIsTracing(false));\n    dispatch(gridSlice.actions.setGrid(initialGrid));\n  }, [dispatch, numRows, numCols, startNodeX, startNodeY, finishNodeX, finishNodeY]);\n\n  // Searching for the finish node.\n  useEffect(() => {\n    if (!isSearching) return;\n\n    const hasFinishSearching = hasVisitedFinishNode(grid, finishNodeX, finishNodeY);\n    const hasNextStep = hasNext(grid);\n\n    if (!hasFinishSearching && hasNextStep) {\n      intervalRef.current = setTimeout(() => {\n        dispatch(gridSlice.actions.setGrid(next(grid)));\n      }, 10);\n      return;\n    }\n\n    if (intervalRef.current !== undefined) {\n      clearInterval(intervalRef.current);\n      dispatch(\n        gridSlice.actions.setGrid(\n          initShortestPathTrace(grid, finishNodeX, finishNodeY)\n        )\n      );\n      dispatch(gridSlice.actions.setIsSearching(false));\n      dispatch(gridSlice.actions.setIsTracing(true));\n    }\n  }, [dispatch, grid, isSearching, finishNodeX, finishNodeY]);\n\n  // Finish node found, trace back to start node.\n  useEffect(() => {\n    if (!isTracing) return;\n\n    if (hasNextPathNode(grid, startNodeX, startNodeY, finishNodeX, finishNodeY)) {\n      intervalRef.current = setTimeout(() => {\n        const nextGrid = nextPathNode(grid, finishNodeX, finishNodeY);\n        dispatch(gridSlice.actions.setGrid(nextGrid));\n      }, 1);\n      return;\n    }\n\n    if (intervalRef.current !== undefined) {\n      clearInterval(intervalRef.current);\n      dispatch(gridSlice.actions.setIsTracing(false));\n      return ;\n    }\n  }, [\n    dispatch,\n    grid,\n    isTracing,\n    startNodeX,\n    startNodeY,\n    finishNodeX,\n    finishNodeY,\n  ]);\n\n  return (\n    <>\n      <div className=\"side-bar\">\n        <Button variant=\"contained\" color=\"primary\" onClick={start}>\n          Just do it\n        </Button>\n\n        <ControlPanel />\n      </div>\n      <div className=\"grid\">\n        {grid?.map((row, rowIndex) => {\n          return (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, nodeIndex) => {\n                return <Components.Node key={nodeIndex} nodeObj={node} />;\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nexport default PathFindingVisualiser;\n","import { configureStore } from '@reduxjs/toolkit';\nimport controlsReducer from 'redux/reducers/controlSlice';\nimport gridSlice from 'redux/reducers/gridSlice';\n\nconst store = configureStore({\n  reducer: {\n    controls: controlsReducer,\n    grid: gridSlice,\n  },\n});\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<typeof store.getState>;\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch;\n\nexport default store;\n","import React from 'react';\nimport './App.css';\nimport PathFindingVisualiser from 'PathFindingVisualiser';\n\nimport { Provider as ReduxProvider } from 'react-redux';\nimport reduxStore from 'redux/store';\n\nfunction App() {\n  return (\n    <ReduxProvider store={reduxStore}>\n      <div className=\"App\">\n        <PathFindingVisualiser />\n      </div>\n    </ReduxProvider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}