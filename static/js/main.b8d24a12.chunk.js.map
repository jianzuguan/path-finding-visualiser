{"version":3,"sources":["utils/perlinNoise.ts","components/index.ts","components/Node.tsx","algorithms/dijkstra.ts","PathFindingVisualiser/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["perlin","components","Node","props","nodeObj","row","col","isStart","isEnd","weight","colourStyle","id","className","style","opacity","updateUnvisitedNeighbors","currentNode","grid","unvisitedNeighbors","node","neighbors","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","newDistance","distance","previousNode","dijkstra","stratNode","finishNode","unvisitedNodes","nodes","getAllNodes","visitedNodesInOrder","sort","nodeA","nodeB","closestNode","shift","Infinity","PERLIN_YWRAP","PERLIN_SIZE","perlin_octaves","perlin_amp_falloff","scaled_cosine","i","Math","cos","PI","noise","x","y","z","Array","random","rxf","ryf","n1","n2","n3","xi","floor","yi","zi","xf","yf","zf","r","ampl","o","of","createNode","NUM_COLS","NUM_ROWS","PathFindingVisualiser","useState","setGrid","animateShortestPath","nodesInShortestPathOrder","setTimeout","domElement","document","getElementById","animateDijkstra","a","useEffect","initialGrid","currentRow","getInitialGrid","onClick","undefined","startNode","endNode","console","log","getNodesInShortestPathOrder","map","rowIndex","nodeIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b8d24a12.chunk.js","sourcesContent":["//////////////////////////////////////////////////////////////\n\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/main/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\n\nconst PERLIN_YWRAPB = 4;\nconst PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\nconst PERLIN_ZWRAPB = 8;\nconst PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\nconst PERLIN_SIZE = 4095;\n\nlet perlin_octaves = 4; // default to medium smooth\nlet perlin_amp_falloff = 0.5; // 50% reduction/octave\n\nconst scaled_cosine = (i:number) => 0.5 * (1.0 - Math.cos(i * Math.PI));\n\nlet perlin:number[] | undefined; // will be initialized lazily by noise() or noiseSeed()\n\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin noise is\n * a random sequence generator producing a more naturally ordered, harmonic\n * succession of numbers compared to the standard <b>random()</b> function.\n * It was invented by Ken Perlin in the 1980s and been used since in\n * graphical applications to produce procedural textures, natural motion,\n * shapes, terrains etc.<br /><br /> The main difference to the\n * <b>random()</b> function is that Perlin noise is defined in an infinite\n * n-dimensional space where each pair of coordinates corresponds to a\n * fixed semi-random value (fixed only for the lifespan of the program; see\n * the <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function). p5.js can compute 1D, 2D and 3D noise,\n * depending on the number of coordinates given. The resulting value will\n * always be between 0.0 and 1.0. The noise value can be animated by moving\n * through the noise space as demonstrated in the example above. The 2nd\n * and 3rd dimension can also be interpreted as time.<br /><br />The actual\n * noise is structured similar to an audio signal, in respect to the\n * function's use of frequencies. Similar to the concept of harmonics in\n * physics, perlin noise is computed over several octaves which are added\n * together for the final result. <br /><br />Another way to adjust the\n * character of the resulting sequence is the scale of the input\n * coordinates. As the function works within an infinite space the value of\n * the coordinates doesn't matter as such, only the distance between\n * successive coordinates does (eg. when using <b>noise()</b> within a\n * loop). As a general rule the smaller the difference between coordinates,\n * the smoother the resulting noise sequence will be. Steps of 0.005-0.03\n * work best for most applications, but this will differ depending on use.\n *\n * @method noise\n * @param  {Number} x   x-coordinate in noise space\n * @param  {Number} [y] y-coordinate in noise space\n * @param  {Number} [z] z-coordinate in noise space\n * @return {Number}     Perlin noise value (between 0 and 1) at specified\n *                      coordinates\n * @example\n * <div>\n * <code>\n * let xoff = 0.0;\n *\n * function draw() {\n *   background(204);\n *   xoff = xoff + 0.01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n * <div>\n * <code>let noiseScale=0.02;\n *\n * function draw() {\n *   background(0);\n *   for (let x=0; x < width; x++) {\n *     let noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);\n *     stroke(noiseVal*255);\n *     line(x, mouseY+noiseVal*80, x, height);\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical line moves left to right with updating noise values.\n * horizontal wave pattern effected by mouse x-position & updating noise values.\n */\n\nexport const noise = function (x:number, y = 0, z = 0) {\n  if (perlin == null) {\n    perlin = new Array(PERLIN_SIZE + 1);\n    for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = Math.random();\n    }\n  }\n\n  if (x < 0) {\n    x = -x;\n  }\n  if (y < 0) {\n    y = -y;\n  }\n  if (z < 0) {\n    z = -z;\n  }\n\n  let xi = Math.floor(x),\n    yi = Math.floor(y),\n    zi = Math.floor(z);\n  let xf = x - xi;\n  let yf = y - yi;\n  let zf = z - zi;\n  let rxf, ryf;\n\n  let r = 0;\n  let ampl = 0.5;\n\n  let n1, n2, n3;\n\n  for (let o = 0; o < perlin_octaves; o++) {\n    let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n\n    rxf = scaled_cosine(xf);\n    ryf = scaled_cosine(yf);\n\n    n1 = perlin[of & PERLIN_SIZE];\n    n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);\n    n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n    n1 += ryf * (n2 - n1);\n\n    of += PERLIN_ZWRAP;\n    n2 = perlin[of & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);\n    n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n    n2 += ryf * (n3 - n2);\n\n    n1 += scaled_cosine(zf) * (n2 - n1);\n\n    r += n1 * ampl;\n    ampl *= perlin_amp_falloff;\n    xi <<= 1;\n    xf *= 2;\n    yi <<= 1;\n    yf *= 2;\n    zi <<= 1;\n    zf *= 2;\n\n    if (xf >= 1.0) {\n      xi++;\n      xf--;\n    }\n    if (yf >= 1.0) {\n      yi++;\n      yf--;\n    }\n    if (zf >= 1.0) {\n      zi++;\n      zf--;\n    }\n  }\n  return r;\n};\n\n/**\n *\n * Adjusts the character and level of detail produced by the Perlin noise\n * function. Similar to harmonics in physics, noise is computed over\n * several octaves. Lower octaves contribute more to the output signal and\n * as such define the overall intensity of the noise, whereas higher octaves\n * create finer grained details in the noise sequence.\n *\n * By default, noise is computed over 4 octaves with each octave contributing\n * exactly half than its predecessor, starting at 50% strength for the 1st\n * octave. This falloff amount can be changed by adding an additional function\n * parameter. Eg. a falloff factor of 0.75 means each octave will now have\n * 75% impact (25% less) of the previous lower octave. Any value between\n * 0.0 and 1.0 is valid, however note that values greater than 0.5 might\n * result in greater than 1.0 values returned by <b>noise()</b>.\n *\n * By changing these parameters, the signal created by the <b>noise()</b>\n * function can be adapted to fit very specific needs and characteristics.\n *\n * @method noiseDetail\n * @param {Number} lod number of octaves to be used by the noise\n * @param {Number} falloff falloff factor for each octave\n * @example\n * <div>\n * <code>\n * let noiseVal;\n * let noiseScale = 0.02;\n *\n * function setup() {\n *   createCanvas(100, 100);\n * }\n *\n * function draw() {\n *   background(0);\n *   for (let y = 0; y < height; y++) {\n *     for (let x = 0; x < width / 2; x++) {\n *       noiseDetail(2, 0.2);\n *       noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n *       stroke(noiseVal * 255);\n *       point(x, y);\n *       noiseDetail(8, 0.65);\n *       noiseVal = noise(\n *         (mouseX + x + width / 2) * noiseScale,\n *         (mouseY + y) * noiseScale\n *       );\n *       stroke(noiseVal * 255);\n *       point(x + width / 2, y);\n *     }\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * 2 vertical grey smokey patterns affected my mouse x-position and noise.\n */\nexport const noiseDetail = function (lod:number, falloff:number) {\n  if (lod > 0) {\n    perlin_octaves = lod;\n  }\n  if (falloff > 0) {\n    perlin_amp_falloff = falloff;\n  }\n};\n\n/**\n * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>\n * produces different results each time the program is run. Set the\n * <b>value</b> parameter to a constant to return the same pseudo-random\n * numbers each time the software is run.\n *\n * @method noiseSeed\n * @param {Number} seed   the seed value\n * @example\n * <div>\n * <code>let xoff = 0.0;\n *\n * function setup() {\n *   noiseSeed(99);\n *   stroke(0, 10);\n * }\n *\n * function draw() {\n *   xoff = xoff + .01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical grey lines drawing in pattern affected by noise.\n */\nexport const noiseSeed = function (seed: number) {\n  // Linear Congruential Generator\n  // Variant of a Lehman Generator\n  const lcg = (() => {\n    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n    // m is basically chosen to be large (as it is the max period)\n    // and for its relationships to a and c\n    const m = 4294967296;\n    // a - 1 should be divisible by m's prime factors\n    const a = 1664525;\n    // c and m should be co-prime\n    const c = 1013904223;\n    let seed: number, z:number;\n    return {\n      setSeed(val:number) {\n        // pick a random seed if val is undefined or null\n        // the >>> 0 casts the seed to an unsigned 32-bit integer\n        z = seed = (val == null ? Math.random() * m : val) >>> 0;\n      },\n      getSeed() {\n        return seed;\n      },\n      rand() {\n        // define the recurrence relationship\n        z = (a * z + c) % m;\n        // return a float in [0, 1)\n        // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n        return z / m;\n      },\n    };\n  })();\n\n  lcg.setSeed(seed);\n  perlin = new Array(PERLIN_SIZE + 1);\n  for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n    perlin[i] = lcg.rand();\n  }\n};\n","import Node from \"./Node\";\n\nconst components = {\n  Node,\n};\n\nexport default components;\n","import \"./Node.css\";\nimport TypeNode from \"../types/Node\";\n\ninterface Props {\n  nodeObj: TypeNode;\n}\n\nconst Node = (props: Props) => {\n  const { row, col, isStart, isEnd, weight } = props.nodeObj;\n\n  const colourStyle = isStart ? \"node-start\" : isEnd ? \"node-end\" : \"\";\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${colourStyle}`}\n      style={{ opacity: weight }}\n    >\n      {/* {weight} */}\n    </div>\n  );\n};\n\nexport default Node;\n","import TypeNode from \"../types/Node\";\n\nconst getAllNodes = (grid: TypeNode[][]) => {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nconst sortNodesByDistance = (unvisitedNoes: TypeNode[]) => {\n  unvisitedNoes.sort(\n    (nodeA: TypeNode, nodeB: TypeNode) => nodeA.distance - nodeB.distance\n  );\n};\n\nconst getUnvisitedNeighbors = (node: TypeNode, grid: TypeNode[][]) => {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};\n\nconst updateUnvisitedNeighbors = (\n  currentNode: TypeNode,\n  grid: TypeNode[][]\n) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const newDistance= currentNode.distance + neighbor.weight;\n    if (newDistance < neighbor.distance) {\n      neighbor.distance = newDistance;\n      neighbor.previousNode = currentNode;\n    }\n  }\n};\n\nconst dijkstra = (\n  grid: TypeNode[][],\n  stratNode: TypeNode,\n  finishNode: TypeNode\n) => {\n  const unvisitedNodes = getAllNodes(grid);\n  stratNode.distance = 0;\n  const visitedNodesInOrder = [];\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (!closestNode) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n\n  return visitedNodesInOrder;\n};\n\nexport const getNodesInShortestPathOrder = (endNode: TypeNode) => {\n  const nodesInShortestPathOrder = [];\n  let currentNode: TypeNode | null = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport default dijkstra;\n","import { useEffect, useState } from \"react\";\nimport TypeNode from \"../types/Node\";\nimport Components from \"../components\";\nimport dijkstra, { getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\nimport \"./index.css\";\nimport { getRandomInt } from \"../utils\";\nimport { noise } from \"../utils/perlinNoise\";\n\nconst NUM_ROWS = 32;\nconst NUM_COLS = 64;\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 10;\nconst END_NODE_ROW = NUM_ROWS - 10;\nconst END_NODE_COL = NUM_COLS - 10;\nconst NOISE_ZOOM = 0.25;\nconst NOISE_OFFSET_ROW = 100;\nconst NOISE_OFFSET_COL = 10;\n\nconst createNode = (col: number, row: number): TypeNode => {\n  return {\n    col,\n    row,\n    isStart: START_NODE_COL === col && START_NODE_ROW === row,\n    isEnd: END_NODE_COL === col && END_NODE_ROW === row,\n    weight: noise(\n      col * NOISE_ZOOM + NOISE_OFFSET_COL,\n      row * NOISE_ZOOM + NOISE_OFFSET_ROW\n    ),\n    distance: Infinity,\n    isVisited: false,\n    previousNode: null,\n  };\n};\n\nconst getInitialGrid = () => {\n  const grid: TypeNode[][] = [];\n  for (let row = 0; row < NUM_ROWS; row++) {\n    const currentRow = [];\n    for (let col = 0; col < NUM_COLS; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst PathFindingVisualiser = () => {\n  const [grid, setGrid] = useState<TypeNode[][]>();\n\n  const animateShortestPath = (nodesInShortestPathOrder: TypeNode[]) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (\n          node === null ||\n          (START_NODE_ROW === node.row && START_NODE_COL === node.col) ||\n          (END_NODE_ROW === node.row && END_NODE_COL === node.col)\n        ) {\n          return;\n        }\n        const domElement = document.getElementById(\n          `node-${node.row}-${node.col}`\n        );\n        if (domElement === null) {\n          return;\n        }\n        domElement.className = \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const animateDijkstra = async (\n    visitedNodesInOrder: TypeNode[],\n    nodesInShortestPathOrder: TypeNode[]\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (\n          node === null ||\n          (START_NODE_ROW === node.row && START_NODE_COL === node.col) ||\n          (END_NODE_ROW === node.row && END_NODE_COL === node.col)\n        ) {\n          return;\n        }\n        const domElement = document.getElementById(\n          `node-${node.row}-${node.col}`\n        );\n        if (domElement !== null) {\n          domElement.className = \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  };\n\n  const visualiseDijkstra = () => {\n    if (grid === undefined) return;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const endNode = grid[END_NODE_ROW][END_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n    console.log(visitedNodesInOrder);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  useEffect(() => {\n    const initialGrid = getInitialGrid();\n    setGrid(initialGrid);\n  }, []);\n  return (\n    <>\n      <div>\n        <button onClick={visualiseDijkstra}>Just do it</button>\n      </div>\n      <div className=\"grid\">\n        {grid?.map((row, rowIndex) => {\n          return (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, nodeIndex) => {\n                return <Components.Node key={nodeIndex} nodeObj={node} />;\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nexport default PathFindingVisualiser;\n","import React from \"react\";\nimport \"./App.css\";\nimport PathFindingVisualiser from \"./PathFindingVisualiser\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualiser />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}