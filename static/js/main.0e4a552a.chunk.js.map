{"version":3,"sources":["utils/perlinNoise.ts","components/index.ts","components/Node.tsx","utils/controlParams.ts","redux/hooks.ts","redux/reducers/controlSlice.ts","PathFindingVisualiser/ControlPanel.tsx","algorithms/dijkstra.ts","utils/createNode.ts","utils/getInitialGrid.ts","redux/reducers/gridSlice.ts","PathFindingVisualiser/index.tsx","redux/store.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["perlin","components","Node","props","nodeObj","row","y","col","x","weight","colourStyle","isStart","isFinish","isInShortestPath","isVisited","id","className","style","opacity","NOISE_ZOOM","useAppDispatch","useDispatch","useAppSelector","useSelector","initialState","numRows","numCols","startNodeX","startNodeY","finishNodeX","NUM_COLS","finishNodeY","NUM_ROWS","noiseOffsetX","noiseOffsetY","instantShowResult","controlsSlice","createSlice","name","reducers","setNumRows","state","action","payload","setNumCols","setStartNodeX","setStartNodeY","setFinishNodeX","setFinishNodeY","setNoiseOffsetX","setNoiseOffsetY","setInstantShowResult","ControlPanel","start","dispatch","controls","onClick","type","checked","onChange","e","actions","target","htmlFor","value","Number","getAllUnvisitedNode","grid","unvisitedNodes","node","push","sortNodesByDistance","unvisitedNoes","sort","nodeA","nodeB","distance","init","gridClone","map","length","hasVisitedFinishNode","hasNext","closestNode","shift","Infinity","next","gridNode","currentNode","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","newDistance","previousNode","updateUnvisitedNeighbors","initShortestPathTrace","hasNextPathNode","nextPathNode","PERLIN_YWRAP","PERLIN_SIZE","perlin_octaves","perlin_amp_falloff","scaled_cosine","i","Math","cos","PI","noise","z","Array","random","rxf","ryf","n1","n2","n3","xi","floor","yi","zi","xf","yf","zf","r","ampl","o","of","createNode","useNoise","getInitialGrid","currentRow","gridSlice","isSearching","isTracing","setGrid","setIsSearching","setIsTracing","PathFindingVisualiser","intervalRef","useRef","useEffect","initialGrid","hasFinishSearching","hasNextStep","undefined","current","clearInterval","setTimeout","nextGrid","currentGrid","rowIndex","nodeIndex","store","configureStore","reducer","controlsReducer","App","reduxStore","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0e4a552a.chunk.js","sourcesContent":["//////////////////////////////////////////////////////////////\n\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/main/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\n\nconst PERLIN_YWRAPB = 4;\nconst PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\nconst PERLIN_ZWRAPB = 8;\nconst PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\nconst PERLIN_SIZE = 4095;\n\nlet perlin_octaves = 4; // default to medium smooth\nlet perlin_amp_falloff = 0.5; // 50% reduction/octave\n\nconst scaled_cosine = (i: number) => 0.5 * (1.0 - Math.cos(i * Math.PI));\n\nlet perlin: number[] | undefined; // will be initialized lazily by noise() or noiseSeed()\n\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin noise is\n * a random sequence generator producing a more naturally ordered, harmonic\n * succession of numbers compared to the standard <b>random()</b> function.\n * It was invented by Ken Perlin in the 1980s and been used since in\n * graphical applications to produce procedural textures, natural motion,\n * shapes, terrains etc.<br /><br /> The main difference to the\n * <b>random()</b> function is that Perlin noise is defined in an infinite\n * n-dimensional space where each pair of coordinates corresponds to a\n * fixed semi-random value (fixed only for the lifespan of the program; see\n * the <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function). p5.js can compute 1D, 2D and 3D noise,\n * depending on the number of coordinates given. The resulting value will\n * always be between 0.0 and 1.0. The noise value can be animated by moving\n * through the noise space as demonstrated in the example above. The 2nd\n * and 3rd dimension can also be interpreted as time.<br /><br />The actual\n * noise is structured similar to an audio signal, in respect to the\n * function's use of frequencies. Similar to the concept of harmonics in\n * physics, perlin noise is computed over several octaves which are added\n * together for the final result. <br /><br />Another way to adjust the\n * character of the resulting sequence is the scale of the input\n * coordinates. As the function works within an infinite space the value of\n * the coordinates doesn't matter as such, only the distance between\n * successive coordinates does (eg. when using <b>noise()</b> within a\n * loop). As a general rule the smaller the difference between coordinates,\n * the smoother the resulting noise sequence will be. Steps of 0.005-0.03\n * work best for most applications, but this will differ depending on use.\n *\n * @method noise\n * @param  {Number} x   x-coordinate in noise space\n * @param  {Number} [y] y-coordinate in noise space\n * @param  {Number} [z] z-coordinate in noise space\n * @return {Number}     Perlin noise value (between 0 and 1) at specified\n *                      coordinates\n * @example\n * <div>\n * <code>\n * let xoff = 0.0;\n *\n * function draw() {\n *   background(204);\n *   xoff = xoff + 0.01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n * <div>\n * <code>let noiseScale=0.02;\n *\n * function draw() {\n *   background(0);\n *   for (let x=0; x < width; x++) {\n *     let noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);\n *     stroke(noiseVal*255);\n *     line(x, mouseY+noiseVal*80, x, height);\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical line moves left to right with updating noise values.\n * horizontal wave pattern effected by mouse x-position & updating noise values.\n */\n\nexport const noise = function (x: number, y = 0, z = 0) {\n  if (perlin == null) {\n    perlin = new Array(PERLIN_SIZE + 1);\n    for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = Math.random();\n    }\n  }\n\n  if (x < 0) {\n    x = -x;\n  }\n  if (y < 0) {\n    y = -y;\n  }\n  if (z < 0) {\n    z = -z;\n  }\n\n  let xi = Math.floor(x),\n    yi = Math.floor(y),\n    zi = Math.floor(z);\n  let xf = x - xi;\n  let yf = y - yi;\n  let zf = z - zi;\n  let rxf, ryf;\n\n  let r = 0;\n  let ampl = 0.5;\n\n  let n1, n2, n3;\n\n  for (let o = 0; o < perlin_octaves; o++) {\n    let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n\n    rxf = scaled_cosine(xf);\n    ryf = scaled_cosine(yf);\n\n    n1 = perlin[of & PERLIN_SIZE];\n    n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);\n    n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n    n1 += ryf * (n2 - n1);\n\n    of += PERLIN_ZWRAP;\n    n2 = perlin[of & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);\n    n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n    n2 += ryf * (n3 - n2);\n\n    n1 += scaled_cosine(zf) * (n2 - n1);\n\n    r += n1 * ampl;\n    ampl *= perlin_amp_falloff;\n    xi <<= 1;\n    xf *= 2;\n    yi <<= 1;\n    yf *= 2;\n    zi <<= 1;\n    zf *= 2;\n\n    if (xf >= 1.0) {\n      xi++;\n      xf--;\n    }\n    if (yf >= 1.0) {\n      yi++;\n      yf--;\n    }\n    if (zf >= 1.0) {\n      zi++;\n      zf--;\n    }\n  }\n  return r;\n};\n\n/**\n *\n * Adjusts the character and level of detail produced by the Perlin noise\n * function. Similar to harmonics in physics, noise is computed over\n * several octaves. Lower octaves contribute more to the output signal and\n * as such define the overall intensity of the noise, whereas higher octaves\n * create finer grained details in the noise sequence.\n *\n * By default, noise is computed over 4 octaves with each octave contributing\n * exactly half than its predecessor, starting at 50% strength for the 1st\n * octave. This falloff amount can be changed by adding an additional function\n * parameter. Eg. a falloff factor of 0.75 means each octave will now have\n * 75% impact (25% less) of the previous lower octave. Any value between\n * 0.0 and 1.0 is valid, however note that values greater than 0.5 might\n * result in greater than 1.0 values returned by <b>noise()</b>.\n *\n * By changing these parameters, the signal created by the <b>noise()</b>\n * function can be adapted to fit very specific needs and characteristics.\n *\n * @method noiseDetail\n * @param {Number} lod number of octaves to be used by the noise\n * @param {Number} falloff falloff factor for each octave\n * @example\n * <div>\n * <code>\n * let noiseVal;\n * let noiseScale = 0.02;\n *\n * function setup() {\n *   createCanvas(100, 100);\n * }\n *\n * function draw() {\n *   background(0);\n *   for (let y = 0; y < height; y++) {\n *     for (let x = 0; x < width / 2; x++) {\n *       noiseDetail(2, 0.2);\n *       noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n *       stroke(noiseVal * 255);\n *       point(x, y);\n *       noiseDetail(8, 0.65);\n *       noiseVal = noise(\n *         (mouseX + x + width / 2) * noiseScale,\n *         (mouseY + y) * noiseScale\n *       );\n *       stroke(noiseVal * 255);\n *       point(x + width / 2, y);\n *     }\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * 2 vertical grey smokey patterns affected my mouse x-position and noise.\n */\nexport const noiseDetail = function (lod: number, falloff: number) {\n  if (lod > 0) {\n    perlin_octaves = lod;\n  }\n  if (falloff > 0) {\n    perlin_amp_falloff = falloff;\n  }\n};\n\n/**\n * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>\n * produces different results each time the program is run. Set the\n * <b>value</b> parameter to a constant to return the same pseudo-random\n * numbers each time the software is run.\n *\n * @method noiseSeed\n * @param {Number} seed   the seed value\n * @example\n * <div>\n * <code>let xoff = 0.0;\n *\n * function setup() {\n *   noiseSeed(99);\n *   stroke(0, 10);\n * }\n *\n * function draw() {\n *   xoff = xoff + .01;\n *   let n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical grey lines drawing in pattern affected by noise.\n */\nexport const noiseSeed = function (seed: number) {\n  // Linear Congruential Generator\n  // Variant of a Lehman Generator\n  const lcg = (() => {\n    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n    // m is basically chosen to be large (as it is the max period)\n    // and for its relationships to a and c\n    const m = 4294967296;\n    // a - 1 should be divisible by m's prime factors\n    const a = 1664525;\n    // c and m should be co-prime\n    const c = 1013904223;\n    let seed: number, z: number;\n    return {\n      setSeed(val: number) {\n        // pick a random seed if val is undefined or null\n        // the >>> 0 casts the seed to an unsigned 32-bit integer\n        z = seed = (val == null ? Math.random() * m : val) >>> 0;\n      },\n      getSeed() {\n        return seed;\n      },\n      rand() {\n        // define the recurrence relationship\n        z = (a * z + c) % m;\n        // return a float in [0, 1)\n        // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n        return z / m;\n      },\n    };\n  })();\n\n  lcg.setSeed(seed);\n  perlin = new Array(PERLIN_SIZE + 1);\n  for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n    perlin[i] = lcg.rand();\n  }\n};\n","import Node from 'components/Node';\n\nconst components = {\n  Node,\n};\n\nexport default components;\n","import 'components/Node.css';\nimport TypeNode from 'types/Node';\n\ninterface Props {\n  nodeObj: TypeNode;\n}\n\nconst calculateClassName = (nodeObj: TypeNode) => {\n  if (nodeObj.isStart) return 'node node-start';\n  if (nodeObj.isFinish) return 'node node-finish';\n  if (nodeObj.isInShortestPath) return 'node node-shortest-path';\n  if (nodeObj.isVisited) return 'node node-visited';\n\n  return 'node';\n};\n\nconst Node = (props: Props) => {\n  const { y: row, x: col, weight } = props.nodeObj;\n\n  const colourStyle = calculateClassName(props.nodeObj);\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={colourStyle}\n      style={{ opacity: weight }}\n    >\n      {/* {weight} */}\n    </div>\n  );\n};\n\nexport default Node;\n","export const NUM_ROWS = 32;\nexport const NUM_COLS = 64;\nexport const START_NODE_X = 10;\nexport const START_NODE_Y = 10;\nexport const FINISH_NODE_X = NUM_COLS - 10;\nexport const FINISH_NODE_Y = NUM_ROWS - 10;\nexport const NOISE_ZOOM = 0.25;\nexport const NOISE_OFFSET_X = 10;\nexport const NOISE_OFFSET_Y = 100;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from 'redux/store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport * as controlsParams from 'utils/controlParams';\n\n// Define a type for the slice state\ninterface controlsState {\n  numRows: number;\n  numCols: number;\n  startNodeX: number;\n  startNodeY: number;\n  finishNodeX: number;\n  finishNodeY: number;\n  noiseOffsetX: number;\n  noiseOffsetY: number;\n  instantShowResult: boolean;\n}\n\n// Define the initial state using that type\nconst initialState: controlsState = {\n  numRows: controlsParams.NUM_ROWS,\n  numCols: controlsParams.NUM_COLS,\n  startNodeX: controlsParams.START_NODE_X,\n  startNodeY: controlsParams.START_NODE_Y,\n  finishNodeX: controlsParams.FINISH_NODE_X,\n  finishNodeY: controlsParams.FINISH_NODE_Y,\n  noiseOffsetX: controlsParams.NOISE_OFFSET_X,\n  noiseOffsetY: controlsParams.NOISE_OFFSET_Y,\n  instantShowResult: true,\n};\n\nexport const controlsSlice = createSlice({\n  name: 'controls',\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState,\n  reducers: {\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    setNumRows: (state, action: PayloadAction<number>) => {\n      state.numRows = action.payload;\n    },\n    setNumCols: (state, action: PayloadAction<number>) => {\n      state.numCols = action.payload;\n    },\n    setStartNodeX: (state, action: PayloadAction<number>) => {\n      state.startNodeX = action.payload;\n    },\n    setStartNodeY: (state, action: PayloadAction<number>) => {\n      state.startNodeY = action.payload;\n    },\n    setFinishNodeX: (state, action: PayloadAction<number>) => {\n      state.finishNodeX = action.payload;\n    },\n    setFinishNodeY: (state, action: PayloadAction<number>) => {\n      state.finishNodeY = action.payload;\n    },\n    setNoiseOffsetX: (state, action: PayloadAction<number>) => {\n      state.noiseOffsetX = action.payload;\n    },\n    setNoiseOffsetY: (state, action: PayloadAction<number>) => {\n      state.noiseOffsetY = action.payload;\n    },\n    setInstantShowResult: (state, action: PayloadAction<boolean>) => {\n      state.instantShowResult = action.payload;\n    },\n  },\n});\n\nexport default controlsSlice.reducer;\n","import { NUM_COLS, NUM_ROWS } from 'utils/controlParams';\nimport { RootState } from 'redux/store';\nimport { useAppDispatch, useAppSelector } from 'redux/hooks';\nimport { controlsSlice } from 'redux/reducers/controlSlice';\n\ninterface Props {\n  start: () => void;\n}\nconst ControlPanel = (props: Props) => {\n  const { start } = props;\n\n  const dispatch = useAppDispatch();\n\n  const instantShowResult = useAppSelector(\n    (state: RootState) => state.controls.instantShowResult\n  );\n  const numRows = useAppSelector((state: RootState) => state.controls.numRows);\n  const numCols = useAppSelector((state: RootState) => state.controls.numCols);\n  const startNodeX = useAppSelector(\n    (state: RootState) => state.controls.startNodeX\n  );\n  const startNodeY = useAppSelector(\n    (state: RootState) => state.controls.startNodeY\n  );\n  const finishNodeX = useAppSelector(\n    (state: RootState) => state.controls.finishNodeX\n  );\n  const finishNodeY = useAppSelector(\n    (state: RootState) => state.controls.finishNodeY\n  );\n\n  return (\n    <div className=\"flex flex-col p-2\">\n      <button\n        className=\"w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-4 px-4 my-4 rounded\"\n        onClick={start}\n      >\n        Just do it\n      </button>\n\n      <label className=\"w-max block text-gray-500 font-bold\">\n        <input\n          type=\"checkbox\"\n          className=\"mr-2 leading-tight\"\n          checked={instantShowResult}\n          onChange={(e) =>\n            dispatch(\n              controlsSlice.actions.setInstantShowResult(e.target.checked)\n            )\n          }\n          name=\"instant-show-result-checkbox\"\n        />\n        <span>Instant show result</span>\n      </label>\n\n      <div className=\"flex flex-row my-4\">\n        <div className=\"flex flex-col mx-2\">\n          <label htmlFor=\"number-of-rows-text-field\" className=\"text-left\">\n            Number of Rows\n          </label>\n          <input\n            type=\"number\"\n            className=\"w-32 px-4 py-2 rounded-lg shadow-md border-gray-300\"\n            name=\"number-of-rows-text-field\"\n            id=\"number-of-rows-text-field\"\n            value={numRows}\n            onChange={(e) =>\n              dispatch(\n                controlsSlice.actions.setNumRows(\n                  Number(e.target.value) || NUM_ROWS\n                )\n              )\n            }\n          />\n        </div>\n        <div className=\"flex flex-col mx-2\">\n          <label htmlFor=\"number-of-cols-text-field\" className=\"text-left\">\n            Number of Columns\n          </label>\n          <input\n            type=\"number\"\n            className=\"w-32 px-4 py-2 rounded-lg shadow-md border-gray-300\"\n            name=\"number-of-cols-text-field\"\n            id=\"number-of-cols-text-field\"\n            value={numCols}\n            onChange={(e) =>\n              dispatch(\n                controlsSlice.actions.setNumCols(\n                  Number(e.target.value) || NUM_COLS\n                )\n              )\n            }\n          />\n        </div>\n      </div>\n\n      <div className=\"flex flex-row my-4\">\n        <div className=\"flex flex-col mx-2\">\n          <label htmlFor=\"start-node-row-text-field\" className=\"text-left\">\n            Start Node Row\n          </label>\n          <input\n            type=\"number\"\n            className=\"w-32 px-4 py-2 rounded-lg shadow-md border-gray-300\"\n            name=\"start-node-row-text-field\"\n            id=\"start-node-row-text-field\"\n            value={startNodeY}\n            onChange={(e) =>\n              dispatch(\n                controlsSlice.actions.setStartNodeY(Number(e.target.value) || 1)\n              )\n            }\n          />\n        </div>\n        <div className=\"flex flex-col mx-2\">\n          <label htmlFor=\"start-node-col-text-field\" className=\"text-left\">\n            Start Node Col\n          </label>\n          <input\n            type=\"number\"\n            className=\"w-32 px-4 py-2 rounded-lg shadow-md border-gray-300\"\n            name=\"start-node-col-text-field\"\n            id=\"start-node-col-text-field\"\n            value={startNodeX}\n            onChange={(e) =>\n              dispatch(\n                controlsSlice.actions.setStartNodeX(Number(e.target.value) || 1)\n              )\n            }\n          />\n        </div>\n      </div>\n\n      <div className=\"flex flex-row my-4\">\n        <div className=\"flex flex-col mx-2\">\n          <label htmlFor=\"finish-node-row-text-field\" className=\"text-left\">\n            Finish Node Row\n          </label>\n          <input\n            type=\"number\"\n            className=\"w-32 px-4 py-2 rounded-lg shadow-md border-gray-300\"\n            name=\"finish-node-row-text-field\"\n            id=\"finish-node-row-text-field\"\n            value={finishNodeY}\n            onChange={(e) =>\n              dispatch(\n                controlsSlice.actions.setFinishNodeY(\n                  Number(e.target.value) || 1\n                )\n              )\n            }\n          />\n        </div>\n        <div className=\"flex flex-col mx-2\">\n          <label htmlFor=\"finish-node-col-text-field\" className=\"text-left\">\n            Finish Node Col\n          </label>\n          <input\n            type=\"number\"\n            className=\"w-32 px-4 py-2 rounded-lg shadow-md border-gray-300\"\n            name=\"finish-node-col-text-field\"\n            id=\"finish-node-col-text-field\"\n            value={finishNodeX}\n            onChange={(e) =>\n              dispatch(\n                controlsSlice.actions.setFinishNodeX(\n                  Number(e.target.value) || 1\n                )\n              )\n            }\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ControlPanel;\n","import TypeNode from 'types/Node';\n\nconst getAllUnvisitedNode = (grid: TypeNode[][]) => {\n  const unvisitedNodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      if (!node.isVisited) {\n        unvisitedNodes.push(node);\n      }\n    }\n  }\n  return unvisitedNodes;\n};\n\nconst sortNodesByDistance = (unvisitedNoes: TypeNode[]) => {\n  unvisitedNoes.sort(\n    (nodeA: TypeNode, nodeB: TypeNode) => nodeA.distance - nodeB.distance\n  );\n};\n\nconst getUnvisitedNeighbors = (node: TypeNode, grid: TypeNode[][]) => {\n  const neighbors = [];\n  const { x: col, y: row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n};\n\nconst updateUnvisitedNeighbors = (\n  currentNode: TypeNode,\n  grid: TypeNode[][]\n) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const newDistance = currentNode.distance + neighbor.weight;\n    if (newDistance < neighbor.distance) {\n      neighbor.distance = newDistance;\n      neighbor.previousNode = currentNode;\n    }\n  }\n};\n\nexport const getNodesInShortestPathOrder = (finishNode: TypeNode) => {\n  const nodesInShortestPathOrder = [];\n  let currentNode: TypeNode | null = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport const init = (\n  grid: TypeNode[][],\n  startNodeX: number,\n  startNodeY: number\n): TypeNode[][] => {\n  const gridClone = [...grid].map((row) => [...row]);\n\n  if (\n    gridClone.length > startNodeY &&\n    gridClone[startNodeY].length > startNodeX\n  ) {\n    gridClone[startNodeY][startNodeX] = {\n      ...gridClone[startNodeY][startNodeX],\n      distance: 0,\n    };\n  }\n\n  return gridClone;\n};\n\nexport const hasVisitedFinishNode = (\n  grid: TypeNode[][],\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  if (finishNodeX < 0 || finishNodeY < 0) {\n    return false;\n  }\n\n  if (grid.length > finishNodeY && grid[finishNodeY].length > finishNodeX) {\n    return grid[finishNodeY][finishNodeX].isVisited;\n  }\n\n  return false;\n};\n\nexport const hasNext = (grid: TypeNode[][]) => {\n  const unvisitedNodes = getAllUnvisitedNode(grid);\n\n  sortNodesByDistance(unvisitedNodes);\n  const closestNode = unvisitedNodes.shift();\n  // All nodes in grid visited.\n  if (!closestNode) return false;\n  // All reachable nodes visited.\n  if (closestNode.distance === Infinity) return false;\n\n  return true;\n};\n\nexport const next = (grid: TypeNode[][]) => {\n  const gridClone = [...grid].map((row) =>\n    [...row].map(function (gridNode: TypeNode) {\n      return { ...gridNode };\n    })\n  );\n\n  const unvisitedNodes = getAllUnvisitedNode(gridClone);\n  sortNodesByDistance(unvisitedNodes);\n  let closestNode = unvisitedNodes.shift();\n  if (!closestNode) return gridClone;\n  closestNode.isVisited = true;\n  updateUnvisitedNeighbors(closestNode, gridClone);\n\n  return gridClone;\n};\n\nexport const initShortestPathTrace = (\n  grid: TypeNode[][],\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  const currentNode: TypeNode = grid[finishNodeY][finishNodeX];\n  if (currentNode.isVisited) {\n    return [...grid].map((row) =>\n      [...row].map(function (gridNode: TypeNode) {\n        if (gridNode.x === finishNodeX && gridNode.y === finishNodeY) {\n          return { ...gridNode, isInShortestPath: true };\n        }\n        return { ...gridNode };\n      })\n    );\n  }\n\n  return grid;\n};\n\nexport const hasNextPathNode = (\n  grid: TypeNode[][],\n  startNodeX: number,\n  startNodeY: number,\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  // Start from finish node and trace back.\n  let currentNode: TypeNode | null = grid[finishNodeY][finishNodeX];\n\n  while (currentNode?.isInShortestPath) {\n    // Node in shortest path means this node already been traced.\n    const previousNode: TypeNode | null = currentNode.previousNode;\n    if (previousNode === null) return grid;\n    currentNode = grid[previousNode.y][previousNode.x];\n  }\n  // Now the currentNode has not been marked as traced.\n\n  if (!currentNode || !currentNode.previousNode) {\n    return false;\n  }\n\n  const startNode: TypeNode = grid[startNodeY][startNodeX];\n  if (currentNode === startNode) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const nextPathNode = (\n  grid: TypeNode[][],\n  finishNodeX: number,\n  finishNodeY: number\n) => {\n  let currentNode: TypeNode | null = grid[finishNodeY][finishNodeX];\n  while (currentNode && currentNode.isInShortestPath) {\n    const previousNode: TypeNode | null = currentNode.previousNode;\n    if (previousNode === null) return grid;\n    currentNode = grid[previousNode.y][previousNode.x];\n  }\n\n  if (currentNode === null) return grid;\n\n  const { x, y } = currentNode;\n  return [...grid].map((row) =>\n    [...row].map(function (gridNode: TypeNode) {\n      if (gridNode.x === x && gridNode.y === y) {\n        const updatedNode = { ...gridNode, isInShortestPath: true };\n        return updatedNode;\n      }\n\n      return { ...gridNode };\n    })\n  );\n};\n","import {\n  NOISE_ZOOM,\n  NOISE_OFFSET_X,\n  NOISE_OFFSET_Y,\n} from 'utils/controlParams';\nimport { noise } from 'utils/perlinNoise';\nimport TypeNode from 'types/Node';\n\nconst createNode = (\n  x: number,\n  y: number,\n  startNodeX: number,\n  startNodeY: number,\n  finishNodeX: number,\n  finishNodeY: number,\n  useNoise: boolean = true\n): TypeNode => {\n  return {\n    x,\n    y,\n    isStart: startNodeX === x && startNodeY === y,\n    isFinish: finishNodeX === x && finishNodeY === y,\n    weight: useNoise\n      ? noise(x * NOISE_ZOOM + NOISE_OFFSET_X, y * NOISE_ZOOM + NOISE_OFFSET_Y)\n      : 1,\n    distance: Infinity,\n    isVisited: false,\n    isInShortestPath: false,\n    previousNode: null,\n  };\n};\n\nexport default createNode;\n","import {\n  NUM_ROWS,\n  NUM_COLS,\n  START_NODE_Y,\n  START_NODE_X,\n  FINISH_NODE_Y,\n  FINISH_NODE_X,\n} from 'utils/controlParams';\nimport TypeNode from 'types/Node';\nimport createNode from 'utils/createNode';\n\nconst getInitialGrid = (\n  numRows = NUM_ROWS,\n  numCols = NUM_COLS,\n  startNodeX = START_NODE_X,\n  startNodeY = START_NODE_Y,\n  finishNodeX = FINISH_NODE_X,\n  finishNodeY = FINISH_NODE_Y\n) => {\n  const grid: TypeNode[][] = [];\n  for (let row = 0; row < numRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < numCols; col++) {\n      currentRow.push(\n        createNode(col, row, startNodeX, startNodeY, finishNodeX, finishNodeY)\n      );\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nexport default getInitialGrid;\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport TypeNode from 'types/Node';\n\n// Define a type for the slice state\ninterface gridState {\n  grid: TypeNode[][];\n  isSearching: boolean;\n  isTracing: boolean;\n}\n\n// Define the initial state using that type\nconst initialState: gridState = {\n  grid: [],\n  isSearching: false,\n  isTracing: false,\n};\n\nexport const gridSlice = createSlice({\n  name: 'grid',\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState,\n  reducers: {\n    setGrid: (state, action: PayloadAction<TypeNode[][]>) => {\n      state.grid = action.payload;\n    },\n    setIsSearching: (state, action: PayloadAction<boolean>) => {\n      state.isSearching = action.payload;\n    },\n    setIsTracing: (state, action: PayloadAction<boolean>) => {\n      state.isTracing = action.payload;\n    },\n  },\n});\n\nexport default gridSlice.reducer;\n","import { useEffect, useRef } from 'react';\nimport TypeNode from 'types/Node';\nimport Components from 'components';\nimport ControlPanel from 'PathFindingVisualiser/ControlPanel';\nimport './index.css';\nimport {\n  hasNext,\n  hasNextPathNode,\n  hasVisitedFinishNode,\n  init,\n  initShortestPathTrace,\n  next,\n  nextPathNode,\n} from 'algorithms/dijkstra';\nimport getInitialGrid from 'utils/getInitialGrid';\nimport { RootState } from 'redux/store';\nimport { useAppDispatch, useAppSelector } from 'redux/hooks';\nimport { gridSlice } from 'redux/reducers/gridSlice';\n\nconst PathFindingVisualiser = () => {\n  const dispatch = useAppDispatch();\n\n  const instantShowResult = useAppSelector(\n    (state: RootState) => state.controls.instantShowResult\n  );\n  const numRows = useAppSelector((state: RootState) => state.controls.numRows);\n  const numCols = useAppSelector((state: RootState) => state.controls.numCols);\n  const startNodeX = useAppSelector(\n    (state: RootState) => state.controls.startNodeX\n  );\n  const startNodeY = useAppSelector(\n    (state: RootState) => state.controls.startNodeY\n  );\n  const finishNodeX = useAppSelector(\n    (state: RootState) => state.controls.finishNodeX\n  );\n  const finishNodeY = useAppSelector(\n    (state: RootState) => state.controls.finishNodeY\n  );\n\n  const grid: TypeNode[][] = useAppSelector(\n    (state: RootState) => state.grid.grid\n  );\n\n  const isSearching: boolean = useAppSelector(\n    (state: RootState) => state.grid.isSearching\n  );\n  const isTracing: boolean = useAppSelector(\n    (state: RootState) => state.grid.isTracing\n  );\n\n  const intervalRef = useRef<NodeJS.Timeout>();\n\n  const start = () => {\n    if (!instantShowResult) {\n      dispatch(gridSlice.actions.setGrid(init(grid, startNodeX, startNodeY)));\n      dispatch(gridSlice.actions.setIsSearching(true));\n      return;\n    }\n\n    let currentGrid = init(grid, startNodeX, startNodeY);\n    while (\n      !hasVisitedFinishNode(currentGrid, finishNodeX, finishNodeY) &&\n      hasNext(currentGrid)\n    ) {\n      currentGrid = next(currentGrid);\n    }\n    currentGrid = initShortestPathTrace(currentGrid, finishNodeX, finishNodeY);\n    while (\n      hasNextPathNode(\n        currentGrid,\n        startNodeX,\n        startNodeY,\n        finishNodeX,\n        finishNodeY,\n      )\n    ) {\n      currentGrid = nextPathNode(currentGrid, finishNodeX, finishNodeY);\n    }\n\n    dispatch(gridSlice.actions.setGrid(currentGrid));\n  };\n\n  // Page loaded and generate a grid.\n  useEffect(() => {\n    const initialGrid = getInitialGrid();\n    dispatch(gridSlice.actions.setGrid(initialGrid));\n  }, [dispatch]);\n\n  // Reset and regenerate the grid.\n  useEffect(() => {\n    const initialGrid = getInitialGrid(\n      numRows,\n      numCols,\n      startNodeX,\n      startNodeY,\n      finishNodeX,\n      finishNodeY\n    );\n    dispatch(gridSlice.actions.setIsSearching(false));\n    dispatch(gridSlice.actions.setIsTracing(false));\n    dispatch(gridSlice.actions.setGrid(initialGrid));\n  }, [\n    dispatch,\n    numRows,\n    numCols,\n    startNodeX,\n    startNodeY,\n    finishNodeX,\n    finishNodeY,\n  ]);\n\n  // Searching for the finish node.\n  useEffect(() => {\n    if (!isSearching) return;\n\n    const hasFinishSearching = hasVisitedFinishNode(\n      grid,\n      finishNodeX,\n      finishNodeY\n    );\n    const hasNextStep = hasNext(grid);\n\n    if (!hasFinishSearching && hasNextStep) {\n      intervalRef.current = setTimeout(() => {\n        dispatch(gridSlice.actions.setGrid(next(grid)));\n      }, 10);\n      return;\n    }\n\n    if (intervalRef.current !== undefined) {\n      clearInterval(intervalRef.current);\n      dispatch(\n        gridSlice.actions.setGrid(\n          initShortestPathTrace(grid, finishNodeX, finishNodeY)\n        )\n      );\n      dispatch(gridSlice.actions.setIsSearching(false));\n      dispatch(gridSlice.actions.setIsTracing(true));\n    }\n  }, [dispatch, grid, isSearching, finishNodeX, finishNodeY]);\n\n  // Finish node found, trace back to start node.\n  useEffect(() => {\n    if (!isTracing) return;\n\n    if (\n      hasNextPathNode(grid, startNodeX, startNodeY, finishNodeX, finishNodeY)\n    ) {\n      intervalRef.current = setTimeout(() => {\n        const nextGrid = nextPathNode(grid, finishNodeX, finishNodeY);\n        dispatch(gridSlice.actions.setGrid(nextGrid));\n      }, 1);\n      return;\n    }\n\n    if (intervalRef.current !== undefined) {\n      clearInterval(intervalRef.current);\n      dispatch(gridSlice.actions.setIsTracing(false));\n      return;\n    }\n  }, [\n    dispatch,\n    grid,\n    isTracing,\n    startNodeX,\n    startNodeY,\n    finishNodeX,\n    finishNodeY,\n  ]);\n\n  return (\n    <>\n      <ControlPanel start={start} />\n      <div className=\"grid\">\n        {grid?.map((row, rowIndex) => {\n          return (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, nodeIndex) => {\n                return <Components.Node key={nodeIndex} nodeObj={node} />;\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nexport default PathFindingVisualiser;\n","import { configureStore } from '@reduxjs/toolkit';\nimport controlsReducer from 'redux/reducers/controlSlice';\nimport gridSlice from 'redux/reducers/gridSlice';\n\nconst store = configureStore({\n  reducer: {\n    controls: controlsReducer,\n    grid: gridSlice,\n  },\n});\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<typeof store.getState>;\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch;\n\nexport default store;\n","import React from 'react';\nimport './App.css';\nimport PathFindingVisualiser from 'PathFindingVisualiser';\n\nimport { Provider as ReduxProvider } from 'react-redux';\nimport reduxStore from 'redux/store';\n\nfunction App() {\n  return (\n    <ReduxProvider store={reduxStore}>\n      <div className=\"App\">\n        <PathFindingVisualiser />\n      </div>\n    </ReduxProvider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}